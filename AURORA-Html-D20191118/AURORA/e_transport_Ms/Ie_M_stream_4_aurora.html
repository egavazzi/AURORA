<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of Ie_M_stream_4_aurora</title>
  <meta name="keywords" content="Ie_M_stream_4_aurora">
  <meta name="description" content="Ie_M_stream_4_aurora - steady-state multi-stream electron transport">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html AURORA --><!-- menu.html e_transport_Ms -->
<h1>Ie_M_stream_4_aurora
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Ie_M_stream_4_aurora - steady-state multi-stream electron transport</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [Ie_zE,mu_pars_out] = Ie_M_stream_4_aurora(h,mag_ze,E,mu_lims,mu_pars,Ie_primary,p_e_q,ne,Te,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Ie_M_stream_4_aurora - steady-state multi-stream electron transport
 
 Calling:  [Ie_zE,mu_pars_out] = Ie_M_stream_4_aurora(h,mag_ze,E,mu_lims,mu_pars,Ie_primary,p_e_q,ne,Te,...
                                     nO,O_levels,XsO,@O_e_2nd_dist,@phase_fcn_O,...
                                     nN2,N2_levels,XsN2,@N2_e_2nd_dist,@phase_fcn_N2,...
                                     % Additional rows for each
                                     % sufficiently abundant species
                                     ni,E_Li,Xsi,@i_e_2nd_dist,@phase_fcn_i);
 Input:
  h       - altitude (m), double array [nZ x 1]
  mag_ze  - magnetic zenith angle (radians), double scalar
  E       - energy grid (eV), double array [1 x nE]
  mu_lims - cosine-of-pitch-angle limits of beams, double array
            [1 x (n_beams+1)], should start and stop with -1 and
            +1 for field-aligned down and up respectively
  mu_pars - cell-array with the output from e_scattering_beamdistribution,
            that is the three-dimensional array with probabilities
            for scattering into each beam and the mateix with the
            solid angles for each pitch-angle in each stream:
            {Pmu2mup,theta2beamW}, if not
            e_scattering_beamdistribution will be calculated with
            181 steps in angles (which seems to be a bit on the
            thin side)
  Ie_primary - cell-array with function-handles to functions for
            the electron fluxes in each stream, for example:
            I_primary{1} = @(t,E) Ie_smooth4(t,E). The function
            should return the electron flux in an energy bin for
            the correspoding stream for the full array of times
            energy-by-energy.
  p_e_q   - internal source of energetic electrons
            (m^-3s^-1 dE^-1), double array, either [nZ x nE] (in
            which case the production is distributed isotropically
            over the pitch-angle-streams) or [(nZ*n_beams) x nE]
            (in which the production is take to be per
            pitch-angle-stream, sorted like the electron fluxes)
  ne      - electron concentration (m^-3), double array [nZ x 1]
  Te      - electron temperature (K), double array [nZ x 1]

  ni      - number density (m^-3) of species with collision cross
            sections, double array [nZ x 1]
  E_Li    - excitation thresholds (eV) of states in ni
            (dE_el,dE_i,E_ion), with number of secondary electrons
            produced for each excitation in the second column,
            double array [nLevels x 2]
  Xsi     - collision cross sections (m^2) (Xs_el;Xs_i;Xs_ion)
            double array [nLevels x nE]
  second_e_E_fcn_i - function for spectrum of secondary electrons
  phase_fcn_i - phase-functions for angular scattering as a
                function of energy and angles, function-handle
                that return the elastic inelastic angular
                scattering probability
  
  The number of species that the electrons collides with is
  arbitrary. It is only required that N_i, E_Lij, Xs_ij,
  second_e_E_fcn_i(E) and phase_fcn are provided for all. 
 
 SEE also: <a href="e_scattering_beamdistribution.html" class="code" title="function [Pmu2mup,theta2beamW,BeamW] = e_scattering_beamdistribution(mu_lims,n_dirs)">e_scattering_beamdistribution</a>, Etrp_*.m</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../AURORA/dEds_ee.html" class="code" title="function Le = dEds_ee(E,ne,Te)">dEds_ee</a>	dEds_ee - suprathermal electron energy loss function in e-e-collisions</li><li><a href="beams2beams.html" class="code" title="function B2B = beams2beams(phase_fcn,Pmu2mup,thetaW)">beams2beams</a>	BEAMS2BEAMS - multi-beam scattering redistribution coefficients</li><li><a href="de_M_stream_us.html" class="code" title="function [Ie_z] = de_M_stream_us(h_atm,mu,I_top_of_mu,QC_mu,A,B_b2b,lowerBvals)">de_M_stream_us</a>	de_M_stream_CNztus - multistream electron transport solver</li><li><a href="e_scattering_beamdistribution.html" class="code" title="function [Pmu2mup,theta2beamW,BeamW] = e_scattering_beamdistribution(mu_lims,n_dirs)">e_scattering_beamdistribution</a>	e_scattering_beamdistribution - angular redistribution PDF for</li><li><a href="mu_avg.html" class="code" title="function c_o_mu = mu_avg(mu_lims)">mu_avg</a>	MU_AVG - pitch-angle averages between limits of cosine-of-pitch-angles</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [Ie_zE,mu_pars_out] = Ie_M_stream_4_aurora(h,mag_ze,E,mu_lims,mu_pars,Ie_primary,p_e_q,ne,Te,varargin)</a>
0002 <span class="comment">% Ie_M_stream_4_aurora - steady-state multi-stream electron transport</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Calling:  [Ie_zE,mu_pars_out] = Ie_M_stream_4_aurora(h,mag_ze,E,mu_lims,mu_pars,Ie_primary,p_e_q,ne,Te,...</span>
0005 <span class="comment">%                                     nO,O_levels,XsO,@O_e_2nd_dist,@phase_fcn_O,...</span>
0006 <span class="comment">%                                     nN2,N2_levels,XsN2,@N2_e_2nd_dist,@phase_fcn_N2,...</span>
0007 <span class="comment">%                                     % Additional rows for each</span>
0008 <span class="comment">%                                     % sufficiently abundant species</span>
0009 <span class="comment">%                                     ni,E_Li,Xsi,@i_e_2nd_dist,@phase_fcn_i);</span>
0010 <span class="comment">% Input:</span>
0011 <span class="comment">%  h       - altitude (m), double array [nZ x 1]</span>
0012 <span class="comment">%  mag_ze  - magnetic zenith angle (radians), double scalar</span>
0013 <span class="comment">%  E       - energy grid (eV), double array [1 x nE]</span>
0014 <span class="comment">%  mu_lims - cosine-of-pitch-angle limits of beams, double array</span>
0015 <span class="comment">%            [1 x (n_beams+1)], should start and stop with -1 and</span>
0016 <span class="comment">%            +1 for field-aligned down and up respectively</span>
0017 <span class="comment">%  mu_pars - cell-array with the output from e_scattering_beamdistribution,</span>
0018 <span class="comment">%            that is the three-dimensional array with probabilities</span>
0019 <span class="comment">%            for scattering into each beam and the mateix with the</span>
0020 <span class="comment">%            solid angles for each pitch-angle in each stream:</span>
0021 <span class="comment">%            {Pmu2mup,theta2beamW}, if not</span>
0022 <span class="comment">%            e_scattering_beamdistribution will be calculated with</span>
0023 <span class="comment">%            181 steps in angles (which seems to be a bit on the</span>
0024 <span class="comment">%            thin side)</span>
0025 <span class="comment">%  Ie_primary - cell-array with function-handles to functions for</span>
0026 <span class="comment">%            the electron fluxes in each stream, for example:</span>
0027 <span class="comment">%            I_primary{1} = @(t,E) Ie_smooth4(t,E). The function</span>
0028 <span class="comment">%            should return the electron flux in an energy bin for</span>
0029 <span class="comment">%            the correspoding stream for the full array of times</span>
0030 <span class="comment">%            energy-by-energy.</span>
0031 <span class="comment">%  p_e_q   - internal source of energetic electrons</span>
0032 <span class="comment">%            (m^-3s^-1 dE^-1), double array, either [nZ x nE] (in</span>
0033 <span class="comment">%            which case the production is distributed isotropically</span>
0034 <span class="comment">%            over the pitch-angle-streams) or [(nZ*n_beams) x nE]</span>
0035 <span class="comment">%            (in which the production is take to be per</span>
0036 <span class="comment">%            pitch-angle-stream, sorted like the electron fluxes)</span>
0037 <span class="comment">%  ne      - electron concentration (m^-3), double array [nZ x 1]</span>
0038 <span class="comment">%  Te      - electron temperature (K), double array [nZ x 1]</span>
0039 <span class="comment">%</span>
0040 <span class="comment">%  ni      - number density (m^-3) of species with collision cross</span>
0041 <span class="comment">%            sections, double array [nZ x 1]</span>
0042 <span class="comment">%  E_Li    - excitation thresholds (eV) of states in ni</span>
0043 <span class="comment">%            (dE_el,dE_i,E_ion), with number of secondary electrons</span>
0044 <span class="comment">%            produced for each excitation in the second column,</span>
0045 <span class="comment">%            double array [nLevels x 2]</span>
0046 <span class="comment">%  Xsi     - collision cross sections (m^2) (Xs_el;Xs_i;Xs_ion)</span>
0047 <span class="comment">%            double array [nLevels x nE]</span>
0048 <span class="comment">%  second_e_E_fcn_i - function for spectrum of secondary electrons</span>
0049 <span class="comment">%  phase_fcn_i - phase-functions for angular scattering as a</span>
0050 <span class="comment">%                function of energy and angles, function-handle</span>
0051 <span class="comment">%                that return the elastic inelastic angular</span>
0052 <span class="comment">%                scattering probability</span>
0053 <span class="comment">%</span>
0054 <span class="comment">%  The number of species that the electrons collides with is</span>
0055 <span class="comment">%  arbitrary. It is only required that N_i, E_Lij, Xs_ij,</span>
0056 <span class="comment">%  second_e_E_fcn_i(E) and phase_fcn are provided for all.</span>
0057 <span class="comment">%</span>
0058 <span class="comment">% SEE also: e_scattering_beamdistribution, Etrp_*.m</span>
0059 
0060 <span class="comment">%  Copyright � Bjorn Gustavsson 20180603, bjorn.gustavsson@uit.no</span>
0061 <span class="comment">%  This is free software, licensed under GNU GPL version 2 or later</span>
0062 
0063 <span class="comment">%wbh = waitbar(1,'Working in the coal mine...');</span>
0064 
0065 second_e_isotropic = 1;
0066 nZ = numel(h);
0067 
0068 <span class="comment">% The functions calculates the electron flux in energy-ranges from</span>
0069 <span class="comment">% E_{i} to E_{i+1}, here we calculate dE</span>
0070 gradE = diff(E);
0071 gradE = gradE([1:end end]);
0072 
0073 <span class="comment">% average pitch-angle cosine</span>
0074 <span class="comment">%beta_m = 1/3^.5;</span>
0075 
0076 <span class="keyword">if</span> iscell(mu_pars)
0077   n_dirs = size(mu_pars{1},2);
0078 <span class="keyword">else</span>
0079   n_dirs = 181;
0080 <span class="keyword">end</span>
0081 theta = linspace(0,pi,n_dirs);
0082 
0083 <span class="comment">% Array for degrading electrons</span>
0084 deg_Ie = zeros(numel(h)*numel(mu_lims(1:end-1)),numel(E));
0085 
0086 
0087 <span class="comment">% electron electron energy loss function...</span>
0088 <span class="comment">%L = esup_e_loss(E,ne,Te);</span>
0089 <span class="comment">%[dLdE,~] = gradient(L,E,h);</span>
0090 
0091 <span class="comment">% ...multiplied with electron density</span>
0092 <span class="comment">%neL = repmat(ne,size(E)).*L;</span>
0093 
0094 Ie_zE = zeros(numel(h)*numel(mu_lims(1:end-1)),numel(E));
0095 Ie_zEpdE = zeros(numel(h)*numel(mu_lims(1:end-1)),1);
0096 
0097 <span class="comment">% AX2 = -inf;</span>
0098 
0099 <span class="comment">%% 2 Calculate the altitude-time-variation of electron fluxes down</span>
0100 <span class="comment">%  and up through the thermosphere, starting at the highest</span>
0101 <span class="comment">%  energy and iterate down in energy. For each energy calculate the</span>
0102 <span class="comment">%  excitation and ionisation of all states in O, N2 and O2 and the</span>
0103 <span class="comment">%  corresponding energy-degradation and production of secondary</span>
0104 <span class="comment">%  electrons.</span>
0105 <span class="keyword">if</span> iscell(mu_pars) &amp;&amp; numel(size(mu_pars{1})) == 3
0106   Pmu2mup     = mu_pars{1};
0107   theta2beamW = mu_pars{2};
0108   mu_pars_out = mu_pars;
0109 <span class="keyword">else</span>
0110   [Pmu2mup,theta2beamW] = <a href="e_scattering_beamdistribution.html" class="code" title="function [Pmu2mup,theta2beamW,BeamW] = e_scattering_beamdistribution(mu_lims,n_dirs)">e_scattering_beamdistribution</a>(mu_lims,n_dirs);
0111   mu_pars_out = {Pmu2mup,theta2beamW};
0112 <span class="keyword">end</span>
0113 c_o_mu = <a href="mu_avg.html" class="code" title="function c_o_mu = mu_avg(mu_lims)">mu_avg</a>(max(-1,min(1,mu_lims)));
0114 BeamWeights = sum(theta2beamW,2);
0115 BeamWeights(c_o_mu&lt;0) = BeamWeights(c_o_mu&lt;0)/sum(BeamWeights(c_o_mu&lt;0));
0116 BeamWeights(c_o_mu&gt;0) = BeamWeights(c_o_mu&gt;0)/sum(BeamWeights(c_o_mu&gt;0));
0117 
0118 elsc_b2b = zeros(numel(h),size(Pmu2mup,3),size(Pmu2mup,3));
0119 <span class="keyword">for</span> iE = length(E):-1:1,
0120   
0121   elsc_b2b = 0*elsc_b2b;
0122 <span class="comment">%   try</span>
0123 <span class="comment">%     waitbar(iE/length(E),wbh);</span>
0124 <span class="comment">%   catch</span>
0125 <span class="comment">%     % Whatever, it becomes tedious...</span>
0126 <span class="comment">%   end</span>
0127   <span class="comment">%% 1: calculate the total and elastic scattering cross-section with</span>
0128   <span class="comment">%  accounting for the energy-dependent back-scattering. This does</span>
0129   <span class="comment">%  not depend on time, only on altitude, through the neutral</span>
0130   <span class="comment">%  density variation, and energy through the cross-sections.</span>
0131   
0132   <span class="comment">% Elastic</span>
0133   <span class="comment">% and inelastic collision cross sections</span>
0134   tot_sc = zeros([length(h) 1]);
0135   <span class="comment">% Loop over all species to calculate total and elastic cross</span>
0136   <span class="comment">% sections, and the corresponding back-scattering ratio:</span>
0137   <span class="keyword">for</span> i1 = 1:5:length(varargin),
0138     
0139     n_i = varargin{i1};   <span class="comment">% Neutral density</span>
0140     xs_i = varargin{i1+2};<span class="comment">% Array with collision cross sections</span>
0141     dE_i = varargin{i1+1};<span class="comment">% Energy levels</span>
0142                           <span class="comment">% second_e_fcn = varargin{i1+3}; % Energy spectra for secondary electrons</span>
0143     ang_scat_fcn = varargin{i1+4}; <span class="comment">% Back scattering ratio (energy</span>
0144                                    <span class="comment">% dependent)</span>
0145                                    <span class="comment">% add the elastic back scattering cross sections together</span>
0146     [curr_phfc_e,curr_phfc_i] = ang_scat_fcn(E(iE),theta(:));
0147     curr_phfc_e = curr_phfc_e.*sin(theta');
0148     curr_phfc_e = curr_phfc_e/sum(curr_phfc_e);
0149     B2B = <a href="beams2beams.html" class="code" title="function B2B = beams2beams(phase_fcn,Pmu2mup,thetaW)">beams2beams</a>(curr_phfc_e,Pmu2mup,theta2beamW);
0150     curr_phfc_i = curr_phfc_i.*sin(theta');
0151     curr_phfc_i = curr_phfc_i/sum(curr_phfc_i);
0152     A2B = <a href="beams2beams.html" class="code" title="function B2B = beams2beams(phase_fcn,Pmu2mup,thetaW)">beams2beams</a>(curr_phfc_i,Pmu2mup,theta2beamW);
0153     <span class="keyword">for</span> i_1 = size(B2B,1):-1:1,
0154       <span class="keyword">for</span> i_2 = size(B2B,2):-1:1
0155         elsc_b2b(:,i_1,i_2) = elsc_b2b(:,i_1,i_2) + n_i*(xs_i(1,iE)*B2B(i_1,i_2));
0156       <span class="keyword">end</span>
0157     <span class="keyword">end</span>
0158     <span class="comment">% add the elastic back scattering to the total</span>
0159     tot_sc = tot_sc + n_i*xs_i(1,iE);
0160     <span class="comment">% add the inelastic collisions to the total</span>
0161     <span class="keyword">for</span> j2 = 2:size(xs_i,1)-1,
0162       
0163       <span class="comment">% The second factor corrects for the case where the energy loss</span>
0164       <span class="comment">% dE_i(j2,1) is smaller than the width in energy in the energy bin</span>
0165       tot_sc = tot_sc + n_i*(xs_i(j2,iE)); <span class="comment">%.*min(1,dE_i(j2,1)./gradE(iE)));</span>
0166       <span class="keyword">for</span> i_1 = size(B2B,1):-1:1,
0167         <span class="keyword">for</span> i_2 = size(B2B,2):-1:1
0168           elsc_b2b(:,i_1,i_2) = ( elsc_b2b(:,i_1,i_2) + <span class="keyword">...</span>
0169                                   n_i*(xs_i(j2,iE)*A2B(i_1,i_2)).*max(0,1-dE_i(j2,1)./gradE(iE)));
0170         <span class="keyword">end</span>
0171       <span class="keyword">end</span>
0172       <span class="comment">% That is when gradE(iE) &gt; dE_i(j2,1) only the fraction</span>
0173       <span class="comment">% dE_i(j2,1)/gradE is lost from the energy bin [E(iE) E(iE)+gradE(iE)]</span>
0174       
0175     <span class="keyword">end</span>
0176     <span class="comment">% Add the ionisation to the total scattering. This requires</span>
0177     <span class="comment">% special treatment since in addition to the ionisation potential</span>
0178     <span class="comment">% primary electrons lose energy to the secondary electrons</span>
0179     j2 = size(xs_i,1);
0180     <span class="comment">% So we calculate the secondary electron spectra</span>
0181     <span class="comment">% second_e_spectra = feval(second_e_fcn,E,E(iE));</span>
0182     <span class="comment">% second_e_spectra = (second_e_spectra + second_e_spectra([2:end end]))/2.*gradE;</span>
0183     <span class="comment">% And the average energy lost to them</span>
0184     <span class="comment">% dE_s = cumsum(second_e_spectra.*E)./cumsum(second_e_spectra);</span>
0185     <span class="comment">% This makes the fraction of electrons lost from the energy bin</span>
0186     <span class="comment">% [E(iE) E(iE)+gradE(iE)]</span>
0187     <span class="comment">% tot_sc = tot_sc + n_i*(xs_i(j2,iE).*min(1,(dE_i(j2,1)+dE_s(iE))./gradE(iE)));</span>
0188     <span class="comment">%% This is a QD-fix since this is not the correct</span>
0189     <span class="comment">%  phase-function for the ionising collisions, but this will</span>
0190     <span class="comment">%  have to do for now.</span>
0191     tot_sc = tot_sc + n_i*(xs_i(j2,iE)); <span class="comment">%.*min(1,dE_i(j2,1)./gradE(iE)));</span>
0192     <span class="keyword">for</span> i_1 = size(B2B,1):-1:1,
0193       <span class="keyword">for</span> i_2 = size(B2B,2):-1:1
0194         elsc_b2b(:,i_1,i_2) = ( elsc_b2b(:,i_1,i_2) + <span class="keyword">...</span>
0195                                 n_i*(xs_i(j2,iE)*A2B(i_1,i_2)).*max(0,1-dE_i(j2,1)./gradE(iE)));
0196       <span class="keyword">end</span>
0197     <span class="keyword">end</span>
0198   <span class="keyword">end</span>
0199   
0200   <span class="comment">% Add the loss due to electron-electron collisions:</span>
0201   A = tot_sc + <a href="../../AURORA/dEds_ee.html" class="code" title="function Le = dEds_ee(E,ne,Te)">dEds_ee</a>(E(iE),ne,Te)/gradE(iE);
0202   
0203   <span class="keyword">if</span> size(p_e_q,1) == numel(h)
0204     <span class="comment">% redistribute isotropically</span>
0205     <span class="keyword">for</span> i_mu = numel(c_o_mu):-1:1
0206       <span class="keyword">if</span> c_o_mu &lt; 0
0207         W = BeamWeights(i_mu)/sum(BeamWeights(c_o_mu&lt;0));
0208       <span class="keyword">else</span>
0209         W = BeamWeights(i_mu)/sum(BeamWeights(c_o_mu&gt;0));
0210       <span class="keyword">end</span>
0211       p_e_Q((1:numel(h))+(i_mu-1)*numel(h)) = p_e_q(:,iE)*W;
0212     <span class="keyword">end</span>
0213   <span class="keyword">else</span> <span class="comment">% p_e_q should be per pitch-angle-stream</span>
0214     p_e_Q = p_e_q(:,iE);
0215   <span class="keyword">end</span>
0216   <span class="keyword">for</span> i_mu = 1:numel(c_o_mu),
0217     Ie_p{i_mu} = Ie_primary{i_mu}(E(iE))*gradE(iE);
0218   <span class="keyword">end</span>
0219   DE = gradE([iE,min(numel(gradE),iE+1)]);
0220   <span class="comment">% This is the call to the standard Crank-Nicholson</span>
0221   <span class="comment">% PDE-integrating function, with  central differences for the</span>
0222   <span class="comment">% spatial gradient</span>
0223   <span class="comment">%    [Ie_ziE] = de_M_stream_CNzt(h/cos(mag_ze),t,c_o_mu,...</span>
0224   <span class="comment">%                               Ie_p,...</span>
0225   <span class="comment">%                               I0_beams,...</span>
0226   <span class="comment">%                               v_of_E(E(iE)),...</span>
0227   <span class="comment">%                               deg_Ie(:,iE)+repmat(p_e_Q(:),size(t)),...</span>
0228   <span class="comment">%                               A,elsc_b2b,...</span>
0229   <span class="comment">%                               ne.*L(:,iE),ne.*dLdE(:,iE),Ie_zEpdE,DE,...</span>
0230   <span class="comment">%                               0);</span>
0231   <span class="comment">% This is the call to the modified Crank-Nicolson PDE-integrating</span>
0232   <span class="comment">% function, with up-stream differences for the spatial gradients</span>
0233   [Ie_ziE] = <a href="de_M_stream_us.html" class="code" title="function [Ie_z] = de_M_stream_us(h_atm,mu,I_top_of_mu,QC_mu,A,B_b2b,lowerBvals)">de_M_stream_us</a>(h/abs(cos(mag_ze)),c_o_mu,<span class="keyword">...</span>
0234                             Ie_p,<span class="keyword">...</span>
0235                             deg_Ie(:,iE)+(p_e_Q(:)),<span class="keyword">...</span>
0236                             A,elsc_b2b, <span class="keyword">...</span>
0237                             0);
0238 <span class="comment">% $$$   [Ie_ziE] = de_M_stream_CNztus(h/cos(mag_ze),c_o_mu,...</span>
0239 <span class="comment">% $$$                                Ie_p,...</span>
0240 <span class="comment">% $$$                                deg_Ie(:,iE)+(p_e_Q(:)),...</span>
0241 <span class="comment">% $$$                                A,elsc_b2b,...</span>
0242 <span class="comment">% $$$                                0);</span>
0243 <span class="comment">% $$$   [Ie_ziE] = de_M_stream_CNztus(h/cos(mag_ze),c_o_mu,...</span>
0244 <span class="comment">% $$$                                Ie_p,...</span>
0245 <span class="comment">% $$$                                deg_Ie(:,iE)+(p_e_Q(:)),...</span>
0246 <span class="comment">% $$$                                A,elsc_b2b,...</span>
0247 <span class="comment">% $$$                                0);</span>
0248   <span class="comment">% TODO: Check if this is often applied outside of at</span>
0249   <span class="comment">% too-low-altitudes:</span>
0250   Ie_ziE(Ie_ziE(:)&lt;0) = 0;
0251   
0252   Ie_zE(:,iE) = Ie_ziE;
0253   Ie_zEpdE = Ie_ziE;
0254   
0255   <span class="comment">%% Calculation of the energy degradation and production of</span>
0256   <span class="comment">%  secondary electrons, starting off with adding the energy</span>
0257   <span class="comment">%  degradation due to electron-electron collisions:</span>
0258   <span class="keyword">if</span> iE &gt; 1
0259     <span class="comment">% This was sure an error, but will it still be?</span>
0260     deg_Ie(:,iE-1) = deg_Ie(:,iE-1) + <span class="keyword">...</span><span class="comment"> % dEds_ee(E(iE),ne,Te)/gradE(iE).*Ie_zE(:,iE).*gradient(h);</span>
0261         repmat(<a href="../../AURORA/dEds_ee.html" class="code" title="function Le = dEds_ee(E,ne,Te)">dEds_ee</a>(E(iE),ne,Te)/gradE(iE),size(c_o_mu(:),1),1).*Ie_zE(:,iE);
0262     <span class="comment">%repmat(dEds_ee(E(iE),ne,Te)/gradE(iE).*gradient(h),size(c_o_mu(:),1),size(t,2)).*Ie_zE(:,iE);</span>
0263   <span class="keyword">end</span> 
0264   <span class="comment">% then continuing done species by species</span>
0265   <span class="keyword">for</span> i1 = 1:5:length(varargin),
0266     
0267     n_i = varargin{i1};   <span class="comment">% Neutral density</span>
0268     xs_i = varargin{i1+2};<span class="comment">% Array with collision cross sections</span>
0269     dE_i = varargin{i1+1};<span class="comment">% Energy levels</span>
0270     second_e_fcn = varargin{i1+3}; <span class="comment">% Energy spectra for secondary electrons</span>
0271     ang_scat_fcn = varargin{i1+4}; <span class="comment">% Back scattering ratio (energy</span>
0272                                    <span class="comment">% dependent)</span>
0273                                    <span class="comment">% add the elastic back scattering cross sections together</span>
0274     [~,curr_phfc_i] = ang_scat_fcn(E(iE),theta(:));
0275     curr_phfc_i = curr_phfc_i.*sin(theta');
0276     curr_phfc_i = curr_phfc_i/sum(curr_phfc_i);
0277     B2B = <a href="beams2beams.html" class="code" title="function B2B = beams2beams(phase_fcn,Pmu2mup,thetaW)">beams2beams</a>(curr_phfc_i,Pmu2mup,theta2beamW);
0278     idx1 = [];
0279     idx2 = [];
0280     Ab2b = [];
0281     <span class="keyword">for</span> i_1 = size(B2B,1):-1:1,
0282       <span class="keyword">for</span> i_2 = size(B2B,2):-1:1,
0283         idx1 = [idx1,(1:numel(h))+(i_1-1)*numel(h)];
0284         idx2 = [idx2,(1:numel(h))+(i_2-1)*numel(h)];
0285         Ab2b = [Ab2b, n_i*B2B(i_1,i_2)];
0286       <span class="keyword">end</span>
0287     <span class="keyword">end</span>
0288     A_b2b = sparse(idx1,idx2,Ab2b);
0289     
0290     <span class="comment">% Now loop over the inelastic collision cross sections (except</span>
0291     <span class="comment">% ionisation):</span>
0292     <span class="comment">% for idE = 2:length(dE_i)-1,</span>
0293     <span class="keyword">for</span> idE = 2:size(dE_i,1),
0294       <span class="keyword">if</span> dE_i(idE,2) &gt; 0
0295         <span class="keyword">break</span>;
0296         <span class="comment">% then we're off to ionisation's</span>
0297       <span class="keyword">end</span>
0298       <span class="comment">% The flux of electrons degraded from energy bin [E(iE) E(iE)+gradE(iE)]</span>
0299       Ie_degraded = (xs_i(idE,iE).*min(1,dE_i(idE,1)./gradE(iE)))*A_b2b*Ie_ziE;
0300       <span class="comment">% to any lower energy bin by excitation of the idE-th state</span>
0301       <span class="comment">% of the current species.</span>
0302       
0303       <span class="comment">% Find the energy bins that the electrons in the current</span>
0304       <span class="comment">% energy bin will degrade to when losing dE_i(idE,1) eV</span>
0305       i_upper = find( E + gradE &gt; E(iE)-dE_i(idE,1) &amp; <span class="keyword">...</span>
0306                       E &lt; E(iE)+gradE(iE)-dE_i(idE,1) );
0307       partition_fract = zeros(size(i_upper));
0308       <span class="keyword">if</span> ( ~isempty(i_upper) &amp;&amp; i_upper(1) &lt; iE ) 
0309         <span class="comment">% Distribute the degrading electrons between those bins</span>
0310         <span class="comment">% (don't ask, figure it out for yourself if you really want</span>
0311         <span class="comment">% to know... ...I have sadly forgotten)</span>
0312         partition_fract(1) = min(1,<span class="keyword">...</span>
0313                                  (E(i_upper(1))+gradE(i_upper(1)) - <span class="keyword">...</span>
0314                                   (E(iE)-dE_i(idE,1)))/gradE(iE));
0315         <span class="keyword">if</span> length(i_upper)&gt;2
0316           partition_fract(2:end-1) = min(1,gradE(i_upper(2:end-1))/gradE(iE));
0317         <span class="keyword">end</span>
0318         partition_fract(end) =  min(1,<span class="keyword">...</span>
0319                                     (E(iE)+gradE(iE)-dE_i(idE,1) - <span class="keyword">...</span>
0320                                      E(i_upper(end)))/gradE(iE));
0321         <span class="keyword">if</span> i_upper(end) == iE
0322           partition_fract(end) = 0;
0323         <span class="keyword">end</span>
0324         partition_fract = partition_fract/sum(partition_fract);
0325         <span class="comment">% Calculate the flux of degrading electrons, sum of those</span>
0326         <span class="comment">% back-scattered, and those that scatter in the forward</span>
0327         <span class="comment">% direction:</span>
0328         <span class="keyword">for</span> i_u = find(partition_fract~=0),<span class="comment">%1:numel(i_upper),</span>
0329           deg_Ie(:,i_upper(i_u)) = ( deg_Ie(:,i_upper(i_u)) + <span class="keyword">...</span>
0330                                      max(0,Ie_degraded) * <span class="keyword">...</span>
0331                                      partition_fract(i_u) );
0332         <span class="keyword">end</span>
0333       <span class="keyword">end</span>
0334       
0335     <span class="keyword">end</span>
0336     <span class="comment">% What remains is the ionisation</span>
0337     <span class="comment">%idE = length(dE_i);</span>
0338     <span class="keyword">for</span> idE2 = idE:size(dE_i,1),
0339       
0340       E_p_d = -( E - ( E(iE)+gradE(iE) - dE_i(idE2,1) ) );
0341       <span class="comment">% Then take care of the ionisation</span>
0342       i_upper = find( E + gradE &gt; E(iE)-dE_i(idE2,1) &amp; <span class="keyword">...</span>
0343                       E &lt; E(iE)+gradE(iE)-dE_i(idE2,1) );<span class="comment">% &amp; ...</span>
0344       <span class="keyword">if</span> ( ~isempty(i_upper) &amp;&amp; i_upper(1) &lt; iE )
0345         <span class="comment">% Calculate the ionisation rate:</span>
0346         <span class="keyword">if</span> second_e_isotropic <span class="comment">% TODO: Insert proper 2nd-ary e</span>
0347                               <span class="comment">% production rates, direction for</span>
0348                               <span class="comment">% direction just as for elastic and</span>
0349                               <span class="comment">% inelastic collisions - except here</span>
0350                               <span class="comment">% we have to do it energy-by-energy/BG-20180921</span>
0351           Ionization = 0*Ie_ziE;
0352           Ionizing = repmat(n_i,numel(c_o_mu),1).*(xs_i(idE2,iE) * Ie_ziE);
0353           <span class="keyword">for</span> i_mu = numel(c_o_mu):-1:1,
0354             Ionization((1:nZ)+nZ*(i_mu-1),:) = max(0,<span class="keyword">...</span>
0355                                                    (n_i).*(xs_i(idE2,iE) * Ie_ziE((1:nZ)+nZ*(i_mu-1)))*<span class="keyword">...</span>
0356                                                    BeamWeights(i_mu)/sum(BeamWeights));
0357           <span class="keyword">end</span>
0358         <span class="keyword">else</span>
0359           Ionizing   = max(0,<span class="keyword">...</span>
0360                            repmat(n_i,numel(c_o_mu),1).*(xs_i(idE2,iE) * Ie_ziE));
0361           Ionization = max(0,<span class="keyword">...</span>
0362                            repmat(n_i,numel(c_o_mu),1).*(xs_i(idE2,iE) * Ie_ziE));
0363         <span class="keyword">end</span>
0364 <span class="comment">% $$$         Ionization = max(0,...</span>
0365 <span class="comment">% $$$                          repmat(n_i,numel(c_o_mu),1).*(xs_i(idE2,iE) * Ie_ziE));</span>
0366         
0367         <span class="comment">% Calculate the spectra of the secondary electrons, using the</span>
0368         <span class="comment">% average energy of the electrons in the current energy bin:</span>
0369         <span class="comment">% second_e_spectra = feval(second_e_fcn,E,E(iE)+gradE(iE)/2);</span>
0370         <span class="comment">% second_e_spectra = feval(second_e_fcn,E,E(iE)+gradE(iE)/2);</span>
0371         <span class="comment">% second_e_spectra = feval(second_e_fcn,E,E(iE),dE_i(idE2,1),'s');</span>
0372         second_e_spectra = second_e_fcn(E,E(iE),dE_i(idE2,1),<span class="string">'s'</span>);
0373         second_e_spectra = (second_e_spectra + second_e_spectra([2:end end]))/2.*gradE;
0374         <span class="comment">% And the distribution of the ionising electrons (that have</span>
0375         <span class="comment">% to lose the corresponding amount of energy)</span>
0376         <span class="comment">% deg_sp = abs(feval(second_e_fcn,max(1,min(( E(iE) - dE_i(idE2,1) )/2,max(0,E_p_d))),E(iE),3));</span>
0377         deg_sp = second_e_fcn(E,E(iE),dE_i(idE2,1),<span class="string">'c'</span>);
0378         
0379         <span class="keyword">if</span> sum(second_e_spectra) &gt; 0
0380           <span class="comment">% Multiply with the number of electrons created - double</span>
0381           <span class="comment">% ionization, double dissociative ionization gives two...</span>
0382           second_e_spectra = dE_i(idE2,2)*second_e_spectra/(sum(second_e_spectra));
0383         <span class="keyword">end</span>
0384         <span class="keyword">if</span> sum(deg_sp) &gt; 0
0385           deg_sp = deg_sp/sum(deg_sp);
0386         <span class="keyword">end</span>
0387         <span class="comment">% TODO: Check that the sum of s_e_s and deg_Sp are the same</span>
0388         e_ionized_distribution = max(second_e_spectra,deg_sp); <span class="comment">% or just sum</span>
0389         e_ionized_distribution(~isfinite(e_ionized_distribution)) = 0;
0390         
0391         
0392         <span class="comment">% Add the ionisation energy and the energy of the secondary</span>
0393         <span class="comment">% electrons to get the degradation energy of the ionising</span>
0394         <span class="comment">% electrons</span>
0395         
0396         
0397         <span class="comment">% and add this to the degrading electron fluxes, here there</span>
0398         <span class="comment">% should be &quot;no&quot; angular-scattering:</span>
0399         <span class="comment">% This part should be possible to move out of the loop over</span>
0400         <span class="comment">% the species</span>
0401 <span class="comment">% $$$         for iI = 1:iE-1,</span>
0402 <span class="comment">% $$$           deg_Ie(:,iI) = deg_Ie(:,iI) + dE_i(idE2,2)*Ionization*e_ionized_distribution(iI);</span>
0403 <span class="comment">% $$$           if e_ionized_distribution(iI) == 0</span>
0404 <span class="comment">% $$$             break</span>
0405 <span class="comment">% $$$           end</span>
0406 <span class="comment">% $$$         end</span>
0407 <span class="comment">% for iI = ,</span>
0408         deg_Ie(:,1:(iE-1)) = deg_Ie(:,1:(iE-1)) + dE_i(idE2,2)*Ionization*e_ionized_distribution(1:(iE-1));
0409         deg_Ie(:,1:(iE-1)) = ( deg_Ie(:,1:(iE-1)) + <span class="keyword">...</span>
0410                                Ionization*second_e_spectra(1:(iE-1)) +<span class="keyword">...</span><span class="comment"> % Isotropic secondaries</span>
0411                                Ionizing*deg_sp(1:(iE-1)) ); <span class="comment">% Forward-scattering primary-e</span>
0412                                                             
0413         <span class="comment">%if e_ionized_distribution(iI) == 0</span>
0414         <span class="comment">%if e_ionized_distribution(iI) == 0</span>
0415         <span class="comment">%    break</span>
0416         <span class="comment">%  end</span>
0417         <span class="comment">%end</span>
0418         <span class="comment">%         for iti = numel(t):-1:1,</span>
0419         <span class="comment">%           deg_Ie(:,iti,:) = squeeze(deg_Ie(:,iti,:)) + dE_i(idE2,2)*Ionization(:,iti)*e_ionized_distribution;</span>
0420         <span class="comment">%         end</span>
0421         <span class="comment">%        for izi = size(Ionization,1):-1:1,</span>
0422         <span class="comment">%          deg_Ie(izi,:,:) = squeeze(deg_Ie(izi,:,:)) + dE_i(idE2,2)*Ionization(izi,:)'*e_ionized_distribution;</span>
0423         <span class="comment">%        end</span>
0424       <span class="keyword">end</span>
0425     <span class="keyword">end</span>
0426     
0427   <span class="keyword">end</span>
0428   <span class="keyword">try</span>
0429     load(<span class="string">'stopnow.dat'</span>)
0430     <span class="keyword">if</span> stopnow == 1 || stopnow==iE
0431       keyboard
0432     <span class="keyword">end</span>
0433   <span class="keyword">catch</span>
0434   <span class="keyword">end</span>
0435   <span class="comment">% waitbar((length(E)-iE)/length(E),wbh);</span>
0436   
0437 <span class="keyword">end</span>
0438 
0439 <span class="comment">% try</span>
0440 <span class="comment">%   close(wbh)</span>
0441 <span class="comment">% catch</span>
0442 <span class="comment">% end</span>
0443</pre></div>
<hr><address>Generated on Mon 18-Nov-2019 14:53:30 by <strong>B.&nbsp;Gustavsson</strong> with <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2003</address>
</body>
</html>