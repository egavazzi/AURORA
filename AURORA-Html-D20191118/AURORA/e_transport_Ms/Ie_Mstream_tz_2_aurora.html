<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of Ie_Mstream_tz_2_aurora</title>
  <meta name="keywords" content="Ie_Mstream_tz_2_aurora">
  <meta name="description" content="Ie_Mstream_tz_2_aurora - time-dependent multi-stream electron transport">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html AURORA --><!-- menu.html e_transport_Ms -->
<h1>Ie_Mstream_tz_2_aurora
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Ie_Mstream_tz_2_aurora - time-dependent multi-stream electron transport</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [Ie_ztE,mu_pars_out] = Ie_Mstream_tz_2_aurora(h,mag_ze,E,mu_lims,mu_pars,t,I0,Ie_primary,p_e_q,ne,Te,OPS,varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Ie_Mstream_tz_2_aurora - time-dependent multi-stream electron transport
 
 Calling: 
  [Ie_ztEG,mu_pars_out] = Ie_Mstream_tz_2_aurora(h,mag_ze,E,mu_lims,mu_scatterings,t,...
                                     I0,Ie_primary,p_e_q,ne,Te,...
                                     OPS
                                     ni,E_Li,Xsi,@i_e_2nd_dist,@phase_fcn_i,...
                                     nO,O_levels,XsO,@O_e_2nd_dist,@phase_fcn_O,...
                                     nN2,N2_levels,XsN2,@N2_e_2nd_dist,@phase_fcn_N2,...
                                     % Additional rows for each
                                     % sufficiently abundant species
                                     nO2,O2_levels,XsO2,@O2_e_2nd_dist,@phase_fcn_O2);
 Input:
  h       - altitude (m), double array [nZ x 1]
  mag_ze  - magnetic zenith angle (radians), double scalar
  E       - energy grid (eV), double array [1 x nE]
  mu_lims - cosine-of-pitch-angle limits of beams, double array
            [1 x (n_beams+1)], should start and stop with -1 and
            +1 for field-aligned down and up respectively
  mu_pars - cell-array with the output from e_scattering_beamdistribution,
            that is the three-dimensional array with probabilities
            for scattering into each beam and the mateix with the
            solid angles for each pitch-angle in each stream:
            {Pmu2mup,theta2beamW}, if not
            e_scattering_beamdistribution will be calculated with
            181 steps in angles (which seems to be a bit on the
            thin side)
  t       - time array (s), double array [1 x n_t]
  I0      - electron flux profile at the start, i.e. initial
            condition (#e/m^2/s/dE), double array [(nZ x n_beams) x 1]
            with the streams stacked in order from most parallel
            to B downward to most paralell to B upwards.
  Ie_primary - cell-array with function-handles to functions for
            the electron fluxes in each stream, for example:
            I_eprimary{1} = @(t,E) Ie_smooth4(t,E). The function
            should return the electron flux in an energy bin for
            the correspoding stream for the full array of times
            energy-by-energy (#e/s/m^2/dE).
  p_e_q   - internal source of energetic electrons
            (m^-3s^-1 dE^-1), double array [nZ x nE]
  ne      - electron concentration (m^-3), double array [nZ x 1]
  Te      - electron temperature (K), double array [nZ x 1]
  OPS     - options struct, optional argument, with parameters
            controlling the electron transport. Fields used:
            OPS.second_e_isotropic - 1 for isotropic production of
            secodary electrons, 0 for forward production.
            OPS.CscD_e - scaling factor for time-of-flight
            spreading/diffusion, ought to be between 0 and 1, zero
            disables time-of-flight smearing due to spread of
            field-aligned velocities within the energy-pitch-angle
            cells.
  ni      - number density (m^-3) of species with collision cross
            sections, double array [nZ x 1]
  E_Li    - excitation thresholds (eV) of states in ni
            (dE_el,dE_i,E_ion), with number of secondary electrons
            produced for each excitation in the second column,
            double array [nLevels x 2]
  Xsi     - collision cross sections (m^2) (Xs_el;Xs_i;Xs_ion)
            double array [nLevels x nE]
  second_e_E_fcn_i - function for spectrum of secondary electrons
  phase_fcn_i - phase-functions for angular scattering as a
                function of energy and angles, function-handle
                that return the elastic inelastic angular
                scattering probability
  
  The number of species that the electrons collides with is
  arbitrary. It is only required that N_i, E_Lij, Xs_ij,
  second_e_E_fcn_i(E) and phase_fcn are provided for all. 
 
 SEE also: <a href="e_scattering_beamdistribution.html" class="code" title="function [Pmu2mup,theta2beamW,BeamW] = e_scattering_beamdistribution(mu_lims,n_dirs)">e_scattering_beamdistribution</a>, Etrp_*.m</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../AURORA/dEds_ee.html" class="code" title="function Le = dEds_ee(E,ne,Te)">dEds_ee</a>	dEds_ee - suprathermal electron energy loss function in e-e-collisions</li><li><a href="beams2beams.html" class="code" title="function B2B = beams2beams(phase_fcn,Pmu2mup,thetaW)">beams2beams</a>	BEAMS2BEAMS - multi-beam scattering redistribution coefficients</li><li><a href="de_M_stream_CNztusD.html" class="code" title="function [Ie_zt] = de_M_stream_CNztusD(h_atm,t_in,mu,I_top_of_t,I0,v,QC_mu,A,B_b2b,Dz,lowerBvals)">de_M_stream_CNztusD</a>	de_M_stream_CNztusD - multistream Crank-Nicholson electron transport</li><li><a href="e_scattering_beamdistribution.html" class="code" title="function [Pmu2mup,theta2beamW,BeamW] = e_scattering_beamdistribution(mu_lims,n_dirs)">e_scattering_beamdistribution</a>	e_scattering_beamdistribution - angular redistribution PDF for</li><li><a href="mu_avg.html" class="code" title="function c_o_mu = mu_avg(mu_lims)">mu_avg</a>	MU_AVG - pitch-angle averages between limits of cosine-of-pitch-angles</li><li><a href="time_of_flight_DOMS_diffusion.html" class="code" title="function D_e = time_of_flight_DOMS_diffusion(E,dE,theta_lims,plotit)">time_of_flight_DOMS_diffusion</a>	TIME_OF_FLIGHT_DOMS_DIFFUSION - Energy-pitch-angle time-of-flight widening</li><li><a href="../../AURORA/utilities/v_of_E.html" class="code" title="function v = v_of_E(E)">v_of_E</a>	v_of_E - convert electron energy (eV) to velocity (m/s)</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../AURORA/sup-scripts/Loop_finalRun_PnL_flickering10beams.html" class="code" title="">Loop_finalRun_PnL_flickering10beams</a>	% Batch-processing-script for FAB-flickering aurora</li><li><a href="../../AURORA/sup-scripts/Loop_first_example_AURORA.html" class="code" title="">Loop_first_example_AURORA</a>	% Example-script for using AURORA the time-dependent electron-transport code</li></ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [Ie_ztE,mu_pars_out] = Ie_Mstream_tz_2_aurora(h,mag_ze,E,mu_lims,mu_pars,t,I0,Ie_primary,p_e_q,ne,Te,OPS,varargin)</a>
0002 <span class="comment">% Ie_Mstream_tz_2_aurora - time-dependent multi-stream electron transport</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Calling:</span>
0005 <span class="comment">%  [Ie_ztEG,mu_pars_out] = Ie_Mstream_tz_2_aurora(h,mag_ze,E,mu_lims,mu_scatterings,t,...</span>
0006 <span class="comment">%                                     I0,Ie_primary,p_e_q,ne,Te,...</span>
0007 <span class="comment">%                                     OPS</span>
0008 <span class="comment">%                                     ni,E_Li,Xsi,@i_e_2nd_dist,@phase_fcn_i,...</span>
0009 <span class="comment">%                                     nO,O_levels,XsO,@O_e_2nd_dist,@phase_fcn_O,...</span>
0010 <span class="comment">%                                     nN2,N2_levels,XsN2,@N2_e_2nd_dist,@phase_fcn_N2,...</span>
0011 <span class="comment">%                                     % Additional rows for each</span>
0012 <span class="comment">%                                     % sufficiently abundant species</span>
0013 <span class="comment">%                                     nO2,O2_levels,XsO2,@O2_e_2nd_dist,@phase_fcn_O2);</span>
0014 <span class="comment">% Input:</span>
0015 <span class="comment">%  h       - altitude (m), double array [nZ x 1]</span>
0016 <span class="comment">%  mag_ze  - magnetic zenith angle (radians), double scalar</span>
0017 <span class="comment">%  E       - energy grid (eV), double array [1 x nE]</span>
0018 <span class="comment">%  mu_lims - cosine-of-pitch-angle limits of beams, double array</span>
0019 <span class="comment">%            [1 x (n_beams+1)], should start and stop with -1 and</span>
0020 <span class="comment">%            +1 for field-aligned down and up respectively</span>
0021 <span class="comment">%  mu_pars - cell-array with the output from e_scattering_beamdistribution,</span>
0022 <span class="comment">%            that is the three-dimensional array with probabilities</span>
0023 <span class="comment">%            for scattering into each beam and the mateix with the</span>
0024 <span class="comment">%            solid angles for each pitch-angle in each stream:</span>
0025 <span class="comment">%            {Pmu2mup,theta2beamW}, if not</span>
0026 <span class="comment">%            e_scattering_beamdistribution will be calculated with</span>
0027 <span class="comment">%            181 steps in angles (which seems to be a bit on the</span>
0028 <span class="comment">%            thin side)</span>
0029 <span class="comment">%  t       - time array (s), double array [1 x n_t]</span>
0030 <span class="comment">%  I0      - electron flux profile at the start, i.e. initial</span>
0031 <span class="comment">%            condition (#e/m^2/s/dE), double array [(nZ x n_beams) x 1]</span>
0032 <span class="comment">%            with the streams stacked in order from most parallel</span>
0033 <span class="comment">%            to B downward to most paralell to B upwards.</span>
0034 <span class="comment">%  Ie_primary - cell-array with function-handles to functions for</span>
0035 <span class="comment">%            the electron fluxes in each stream, for example:</span>
0036 <span class="comment">%            I_eprimary{1} = @(t,E) Ie_smooth4(t,E). The function</span>
0037 <span class="comment">%            should return the electron flux in an energy bin for</span>
0038 <span class="comment">%            the correspoding stream for the full array of times</span>
0039 <span class="comment">%            energy-by-energy (#e/s/m^2/dE).</span>
0040 <span class="comment">%  p_e_q   - internal source of energetic electrons</span>
0041 <span class="comment">%            (m^-3s^-1 dE^-1), double array [nZ x nE]</span>
0042 <span class="comment">%  ne      - electron concentration (m^-3), double array [nZ x 1]</span>
0043 <span class="comment">%  Te      - electron temperature (K), double array [nZ x 1]</span>
0044 <span class="comment">%  OPS     - options struct, optional argument, with parameters</span>
0045 <span class="comment">%            controlling the electron transport. Fields used:</span>
0046 <span class="comment">%            OPS.second_e_isotropic - 1 for isotropic production of</span>
0047 <span class="comment">%            secodary electrons, 0 for forward production.</span>
0048 <span class="comment">%            OPS.CscD_e - scaling factor for time-of-flight</span>
0049 <span class="comment">%            spreading/diffusion, ought to be between 0 and 1, zero</span>
0050 <span class="comment">%            disables time-of-flight smearing due to spread of</span>
0051 <span class="comment">%            field-aligned velocities within the energy-pitch-angle</span>
0052 <span class="comment">%            cells.</span>
0053 <span class="comment">%  ni      - number density (m^-3) of species with collision cross</span>
0054 <span class="comment">%            sections, double array [nZ x 1]</span>
0055 <span class="comment">%  E_Li    - excitation thresholds (eV) of states in ni</span>
0056 <span class="comment">%            (dE_el,dE_i,E_ion), with number of secondary electrons</span>
0057 <span class="comment">%            produced for each excitation in the second column,</span>
0058 <span class="comment">%            double array [nLevels x 2]</span>
0059 <span class="comment">%  Xsi     - collision cross sections (m^2) (Xs_el;Xs_i;Xs_ion)</span>
0060 <span class="comment">%            double array [nLevels x nE]</span>
0061 <span class="comment">%  second_e_E_fcn_i - function for spectrum of secondary electrons</span>
0062 <span class="comment">%  phase_fcn_i - phase-functions for angular scattering as a</span>
0063 <span class="comment">%                function of energy and angles, function-handle</span>
0064 <span class="comment">%                that return the elastic inelastic angular</span>
0065 <span class="comment">%                scattering probability</span>
0066 <span class="comment">%</span>
0067 <span class="comment">%  The number of species that the electrons collides with is</span>
0068 <span class="comment">%  arbitrary. It is only required that N_i, E_Lij, Xs_ij,</span>
0069 <span class="comment">%  second_e_E_fcn_i(E) and phase_fcn are provided for all.</span>
0070 <span class="comment">%</span>
0071 <span class="comment">% SEE also: e_scattering_beamdistribution, Etrp_*.m</span>
0072 
0073 <span class="comment">%  Copyright � Bjorn Gustavsson 20180603, bjorn.gustavsson@uit.no</span>
0074 <span class="comment">%  This is free software, licensed under GNU GPL version 2 or later</span>
0075 
0076 <span class="comment">%wbh = waitbar(1,'Working in the coal mine...');</span>
0077 
0078 dOPS.second_e_isotropic = 1;
0079 dOPS.CscD_e = 1;
0080 
0081 <span class="keyword">if</span> ~isempty(OPS) &amp;&amp; isstruct(OPS)
0082   dOPS = merge_structs(dOPS,OPS);
0083 <span class="keyword">end</span>
0084 
0085 second_e_isotropic = dOPS.second_e_isotropic;
0086 CscD_e = dOPS.CscD_e
0087 nZ = numel(h);
0088 
0089 <span class="comment">% The functions calculates the electron flux in energy-ranges from</span>
0090 <span class="comment">% E_{i} to E_{i+1}, here we calculate dE</span>
0091 gradE = diff(E);
0092 gradE = gradE([1:end end]);
0093 
0094 <span class="comment">% average pitch-angle cosine</span>
0095 <span class="comment">%beta_m = 1/3^.5;</span>
0096 
0097 <span class="keyword">if</span> iscell(mu_pars)
0098   n_dirs = size(mu_pars{1},2);
0099 <span class="keyword">else</span>
0100   n_dirs = 181;
0101 <span class="keyword">end</span>
0102 theta = linspace(0,pi,n_dirs);
0103 
0104 <span class="comment">% Array for degrading electrons</span>
0105 deg_Ie = zeros(numel(h)*numel(mu_lims(1:end-1)),numel(t),numel(E));
0106 
0107 
0108 <span class="comment">% electron electron energy loss function...</span>
0109 <span class="comment">%L = esup_e_loss(E,ne,Te);</span>
0110 <span class="comment">%[dLdE,~] = gradient(L,E,h);</span>
0111 
0112 <span class="comment">% ...multiplied with electron density</span>
0113 <span class="comment">%neL = repmat(ne,size(E)).*L;</span>
0114 
0115 Ie_ztE = zeros(numel(h)*numel(mu_lims(1:end-1)),numel(t),numel(E));
0116 Ie_ztEpdE = zeros(numel(h)*numel(mu_lims(1:end-1)),numel(t));
0117 
0118 <span class="comment">% AX2 = -inf;</span>
0119 
0120 <span class="comment">%% 2 Calculate the altitude-time-variation of electron fluxes down</span>
0121 <span class="comment">%  and up through the thermosphere, starting at the highest</span>
0122 <span class="comment">%  energy and iterate down in energy. For each energy calculate the</span>
0123 <span class="comment">%  excitation and ionisation of all states in O, N2 and O2 and the</span>
0124 <span class="comment">%  corresponding energy-degradation and production of secondary</span>
0125 <span class="comment">%  electrons.</span>
0126 <span class="keyword">if</span> iscell(mu_pars) &amp;&amp; numel(size(mu_pars{1})) == 3
0127   Pmu2mup     = mu_pars{1};
0128   theta2beamW = mu_pars{2};
0129   mu_pars_out = mu_pars;
0130 <span class="keyword">else</span>
0131   [Pmu2mup,theta2beamW] = <a href="e_scattering_beamdistribution.html" class="code" title="function [Pmu2mup,theta2beamW,BeamW] = e_scattering_beamdistribution(mu_lims,n_dirs)">e_scattering_beamdistribution</a>(mu_lims,n_dirs);
0132   mu_pars_out = {Pmu2mup,theta2beamW};
0133 <span class="keyword">end</span>
0134 c_o_mu = <a href="mu_avg.html" class="code" title="function c_o_mu = mu_avg(mu_lims)">mu_avg</a>(max(-1,min(1,mu_lims)));
0135 BeamWeights = sum(theta2beamW,2);
0136 BeamWeights(c_o_mu&lt;0) = BeamWeights(c_o_mu&lt;0)/sum(BeamWeights(c_o_mu&lt;0));
0137 BeamWeights(c_o_mu&gt;0) = BeamWeights(c_o_mu&gt;0)/sum(BeamWeights(c_o_mu&gt;0));
0138 
0139 elsc_b2b = zeros(numel(h),size(Pmu2mup,3),size(Pmu2mup,3));
0140 theta_lims = acos(mu_lims);
0141 <span class="comment">% D_e = time_of_flight_DOMS_diffusion(E(10:20:end),gradE(10:20:end),theta_lims,0);</span>
0142 D_e = <a href="time_of_flight_DOMS_diffusion.html" class="code" title="function D_e = time_of_flight_DOMS_diffusion(E,dE,theta_lims,plotit)">time_of_flight_DOMS_diffusion</a>(E,gradE,theta_lims,0); <span class="comment">% seems</span>
0143                                                            <span class="comment">% to</span>
0144                                                            <span class="comment">% take ~5s</span>
0145 D_e = D_e.*CscD_e;
0146 
0147 
0148 <span class="keyword">for</span> iE = length(E):-1:1,
0149   
0150   elsc_b2b = 0*elsc_b2b;
0151 <span class="comment">%   try</span>
0152 <span class="comment">%     waitbar(iE/length(E),wbh);</span>
0153 <span class="comment">%   catch</span>
0154 <span class="comment">%     % Whatever, it becomes tedious...</span>
0155 <span class="comment">%   end</span>
0156   <span class="comment">%% 1: calculate the total and elastic scattering cross-section with</span>
0157   <span class="comment">%  accounting for the energy-dependent back-scattering. This does</span>
0158   <span class="comment">%  not depend on time, only on altitude, through the neutral</span>
0159   <span class="comment">%  density variation, and energy through the cross-sections.</span>
0160   
0161   <span class="comment">% Elastic</span>
0162   <span class="comment">% and inelastic collision cross sections</span>
0163   tot_sc = zeros([length(h) 1]);
0164   <span class="comment">% Loop over all species to calculate total and elastic cross</span>
0165   <span class="comment">% sections, and the corresponding back-scattering ratio:</span>
0166   <span class="keyword">for</span> i1 = 1:5:length(varargin),
0167     
0168     n_i = varargin{i1};   <span class="comment">% Neutral density</span>
0169     xs_i = varargin{i1+2};<span class="comment">% Array with collision cross sections</span>
0170     dE_i = varargin{i1+1};<span class="comment">% Energy levels</span>
0171     <span class="comment">% second_e_fcn = varargin{i1+3}; % Energy spectra for secondary electrons</span>
0172     ang_scat_fcn = varargin{i1+4}; <span class="comment">% Back scattering ratio (energy</span>
0173                                       <span class="comment">% dependent)</span>
0174                                       <span class="comment">% add the elastic back scattering cross sections together</span>
0175     <span class="comment">% TODO: In with curr_phfc_2nde and  curr_phfc_primary_e</span>
0176     [curr_phfc_e,curr_phfc_i] = ang_scat_fcn(E(iE),theta(:));
0177     curr_phfc_e = curr_phfc_e.*sin(theta');
0178     curr_phfc_e = curr_phfc_e/sum(curr_phfc_e);
0179     B2B = <a href="beams2beams.html" class="code" title="function B2B = beams2beams(phase_fcn,Pmu2mup,thetaW)">beams2beams</a>(curr_phfc_e,Pmu2mup,theta2beamW);
0180     curr_phfc_i = curr_phfc_i.*sin(theta');
0181     curr_phfc_i = curr_phfc_i/sum(curr_phfc_i);
0182     A2B = <a href="beams2beams.html" class="code" title="function B2B = beams2beams(phase_fcn,Pmu2mup,thetaW)">beams2beams</a>(curr_phfc_i,Pmu2mup,theta2beamW);
0183     <span class="keyword">for</span> i_1 = size(B2B,1):-1:1,
0184       <span class="keyword">for</span> i_2 = size(B2B,2):-1:1
0185         elsc_b2b(:,i_1,i_2) = elsc_b2b(:,i_1,i_2) + n_i*(xs_i(1,iE)*B2B(i_1,i_2));
0186       <span class="keyword">end</span>
0187     <span class="keyword">end</span>
0188     <span class="comment">% add the elastic back scattering to the total</span>
0189     tot_sc = tot_sc + n_i*xs_i(1,iE);
0190     <span class="comment">% add the inelastic collisions to the total</span>
0191     <span class="keyword">for</span> j2 = 2:size(xs_i,1)-1,
0192       
0193       <span class="comment">% The second factor corrects for the case where the energy loss</span>
0194       <span class="comment">% dE_i(j2,1) is smaller than the width in energy in the energy bin</span>
0195       tot_sc = tot_sc + n_i*(xs_i(j2,iE)); <span class="comment">%.*min(1,dE_i(j2,1)./gradE(iE)));</span>
0196       <span class="keyword">for</span> i_1 = size(B2B,1):-1:1,
0197         <span class="keyword">for</span> i_2 = size(B2B,2):-1:1
0198           elsc_b2b(:,i_1,i_2) = ( elsc_b2b(:,i_1,i_2) + <span class="keyword">...</span>
0199                                   n_i*(xs_i(j2,iE)*A2B(i_1,i_2)).*max(0,1-dE_i(j2,1)./gradE(iE)));
0200         <span class="keyword">end</span>
0201       <span class="keyword">end</span>
0202       <span class="comment">% That is when gradE(iE) &gt; dE_i(j2,1) only the fraction</span>
0203       <span class="comment">% dE_i(j2,1)/gradE is lost from the energy bin [E(iE) E(iE)+gradE(iE)]</span>
0204       
0205     <span class="keyword">end</span>
0206     <span class="comment">% Add the ionisation to the total scattering. This requires</span>
0207     <span class="comment">% special treatment since in addition to the ionisation potential</span>
0208     <span class="comment">% primary electrons lose energy to the secondary electrons</span>
0209     j2 = size(xs_i,1);
0210     <span class="comment">% So we calculate the secondary electron spectra</span>
0211     <span class="comment">% second_e_spectra = feval(second_e_fcn,E,E(iE));</span>
0212     <span class="comment">% second_e_spectra = (second_e_spectra + second_e_spectra([2:end end]))/2.*gradE;</span>
0213     <span class="comment">% And the average energy lost to them</span>
0214     <span class="comment">% dE_s = cumsum(second_e_spectra.*E)./cumsum(second_e_spectra);</span>
0215     <span class="comment">% This makes the fraction of electrons lost from the energy bin</span>
0216     <span class="comment">% [E(iE) E(iE)+gradE(iE)]</span>
0217     <span class="comment">% tot_sc = tot_sc + n_i*(xs_i(j2,iE).*min(1,(dE_i(j2,1)+dE_s(iE))./gradE(iE)));</span>
0218     <span class="comment">%% This is a QD-fix since this is not the correct</span>
0219     <span class="comment">%  phase-function for the ionising collisions, but this will</span>
0220     <span class="comment">%  have to do for now.</span>
0221     tot_sc = tot_sc + n_i*(xs_i(j2,iE)); <span class="comment">%.*min(1,dE_i(j2,1)./gradE(iE)));</span>
0222     <span class="keyword">for</span> i_1 = size(B2B,1):-1:1,
0223       <span class="keyword">for</span> i_2 = size(B2B,2):-1:1
0224         elsc_b2b(:,i_1,i_2) = ( elsc_b2b(:,i_1,i_2) + <span class="keyword">...</span>
0225                                 n_i*(xs_i(j2,iE)*A2B(i_1,i_2)).*max(0,1-dE_i(j2,1)./gradE(iE)));
0226       <span class="keyword">end</span>
0227     <span class="keyword">end</span>
0228   <span class="keyword">end</span>
0229   
0230   <span class="comment">% Add the loss due to electron-electron collisions:</span>
0231   A = tot_sc + <a href="../../AURORA/dEds_ee.html" class="code" title="function Le = dEds_ee(E,ne,Te)">dEds_ee</a>(E(iE),ne,Te)/gradE(iE);
0232   I0_beams = I0(:,min(iE,size(I0,2)));
0233   <span class="keyword">for</span> i_mu = numel(c_o_mu):-1:1
0234     <span class="keyword">if</span> c_o_mu &lt; 0
0235       W = BeamWeights(i_mu)/sum(BeamWeights(c_o_mu&lt;0));
0236     <span class="keyword">else</span>
0237       W = BeamWeights(i_mu)/sum(BeamWeights(c_o_mu&gt;0));
0238     <span class="keyword">end</span>
0239     p_e_Q((1:numel(h))+(i_mu-1)*numel(h)) = p_e_q(:,iE)*W;
0240   <span class="keyword">end</span>
0241   <span class="keyword">for</span> i_mu = 1:numel(c_o_mu),
0242     Ie_p{i_mu} = Ie_primary{i_mu}(t/2+t([2:<span class="keyword">end</span>,end])/2,E(iE));<span class="comment">% *gradE(iE);</span>
0243   <span class="keyword">end</span>
0244   DE = gradE([iE,min(numel(gradE),iE+1)]);
0245   <span class="comment">% This is the call to the standard Crank-Nicholson</span>
0246   <span class="comment">% PDE-integrating function, with  central differences for the</span>
0247   <span class="comment">% spatial gradient</span>
0248   <span class="comment">%    [Ie_zt] = de_M_stream_CNzt(h/cos(mag_ze),t,c_o_mu,...</span>
0249   <span class="comment">%                               Ie_p,...</span>
0250   <span class="comment">%                               I0_beams,...</span>
0251   <span class="comment">%                               v_of_E(E(iE)),...</span>
0252   <span class="comment">%                               deg_Ie(:,:,iE)+repmat(p_e_Q(:),size(t)),...</span>
0253   <span class="comment">%                               A,elsc_b2b,...</span>
0254   <span class="comment">%                               ne.*L(:,iE),ne.*dLdE(:,iE),Ie_ztEpdE,DE,...</span>
0255   <span class="comment">%                               0);</span>
0256   <span class="comment">% This is the call to the modified Crank-Nicolson PDE-integrating</span>
0257   <span class="comment">% function, with up-stream differences for the spatial gradients</span>
0258   <span class="comment">% D_e = min(1e-3,DaFcn(E(iE)));</span>
0259   
0260   [Ie_zt] = <a href="de_M_stream_CNztusD.html" class="code" title="function [Ie_zt] = de_M_stream_CNztusD(h_atm,t_in,mu,I_top_of_t,I0,v,QC_mu,A,B_b2b,Dz,lowerBvals)">de_M_stream_CNztusD</a>(h/cos(mag_ze),t,c_o_mu,<span class="keyword">...</span>
0261                                 Ie_p,<span class="keyword">...</span>
0262                                 I0_beams,<span class="keyword">...</span>
0263                                 <a href="../../AURORA/utilities/v_of_E.html" class="code" title="function v = v_of_E(E)">v_of_E</a>(E(iE)),<span class="keyword">...</span>
0264                                 deg_Ie(:,:,iE)+repmat(p_e_Q(:),size(t)),<span class="keyword">...</span>
0265                                 A,elsc_b2b,<span class="keyword">...</span>
0266                                 D_e(iE,:));
0267   <span class="comment">% TODO: Check if this is often applied outside of at</span>
0268   <span class="comment">% too-low-altitudes:</span>
0269   Ie_zt(Ie_zt(:)&lt;0) = 0;
0270   
0271   Ie_ztE(:,:,iE) = Ie_zt;
0272   Ie_ztEpdE = Ie_zt;
0273   
0274   <span class="comment">%% Calculation of the energy degradation and production of</span>
0275   <span class="comment">%  secondary electrons, starting off with adding the energy</span>
0276   <span class="comment">%  degradation due to electron-electron collisions:</span>
0277   <span class="keyword">if</span> iE &gt; 1
0278     <span class="comment">% This was sure an error, but will it still be?</span>
0279     deg_Ie(:,:,iE-1) = deg_Ie(:,:,iE-1) + <span class="keyword">...</span><span class="comment"> % dEds_ee(E(iE),ne,Te)/gradE(iE).*Ie_ztE(:,:,iE).*gradient(h);</span>
0280         repmat(<a href="../../AURORA/dEds_ee.html" class="code" title="function Le = dEds_ee(E,ne,Te)">dEds_ee</a>(E(iE),ne,Te)/gradE(iE),size(c_o_mu(:),1),size(t,2)).*Ie_ztE(:,:,iE);
0281     <span class="comment">%repmat(dEds_ee(E(iE),ne,Te)/gradE(iE).*gradient(h),size(c_o_mu(:),1),size(t,2)).*Ie_ztE(:,:,iE);</span>
0282   <span class="keyword">end</span> 
0283   <span class="comment">% then continuing done species by species</span>
0284   <span class="keyword">for</span> i1 = 1:5:length(varargin),
0285     
0286     n_i = varargin{i1};   <span class="comment">% Neutral density</span>
0287     xs_i = varargin{i1+2};<span class="comment">% Array with collision cross sections</span>
0288     dE_i = varargin{i1+1};<span class="comment">% Energy levels</span>
0289     second_e_fcn = varargin{i1+3}; <span class="comment">% Energy spectra for secondary electrons</span>
0290     ang_scat_fcn = varargin{i1+4}; <span class="comment">% Back scattering ratio (energy</span>
0291                                       <span class="comment">% dependent)</span>
0292                                       <span class="comment">% add the elastic back scattering cross sections together</span>
0293     [~,curr_phfc_i] = ang_scat_fcn(E(iE),theta(:));
0294     curr_phfc_i = curr_phfc_i.*sin(theta');
0295     curr_phfc_i = curr_phfc_i/sum(curr_phfc_i);
0296     B2B = <a href="beams2beams.html" class="code" title="function B2B = beams2beams(phase_fcn,Pmu2mup,thetaW)">beams2beams</a>(curr_phfc_i,Pmu2mup,theta2beamW);
0297     idx1 = [];
0298     idx2 = [];
0299     Ab2b = [];
0300     <span class="keyword">for</span> i_1 = size(B2B,1):-1:1,
0301       <span class="keyword">for</span> i_2 = size(B2B,2):-1:1,
0302         idx1 = [idx1,(1:numel(h))+(i_1-1)*numel(h)];
0303         idx2 = [idx2,(1:numel(h))+(i_2-1)*numel(h)];
0304         Ab2b = [Ab2b, n_i*B2B(i_1,i_2)];
0305       <span class="keyword">end</span>
0306     <span class="keyword">end</span>
0307     A_b2b = sparse(idx1,idx2,Ab2b);
0308     
0309     <span class="comment">% Now loop over the inelastic collision cross sections (except</span>
0310     <span class="comment">% ionisation):</span>
0311     <span class="comment">% for idE = 2:length(dE_i)-1,</span>
0312     <span class="keyword">for</span> idE = 2:size(dE_i,1),
0313       <span class="keyword">if</span> dE_i(idE,2) &gt; 0
0314         <span class="keyword">break</span>;
0315         <span class="comment">% then we're off to ionisation's</span>
0316       <span class="keyword">end</span>
0317       <span class="comment">% The flux of electrons degraded from energy bin [E(iE) E(iE)+gradE(iE)]</span>
0318       Ie_degraded = (xs_i(idE,iE).*min(1,dE_i(idE,1)./gradE(iE)))*A_b2b*Ie_zt;
0319       <span class="comment">% to any lower energy bin by excitation of the idE-th state</span>
0320       <span class="comment">% of the current species.</span>
0321       
0322       <span class="comment">% Find the energy bins that the electrons in the current</span>
0323       <span class="comment">% energy bin will degrade to when losing dE_i(idE,1) eV</span>
0324       i_upper = find( E + gradE &gt; E(iE)-dE_i(idE,1) &amp; <span class="keyword">...</span>
0325                       E &lt; E(iE)+gradE(iE)-dE_i(idE,1) );
0326       partition_fract = zeros(size(i_upper));
0327       <span class="keyword">if</span> ( ~isempty(i_upper) &amp;&amp; i_upper(1) &lt; iE ) <span class="comment">%Â¤</span>
0328         <span class="comment">% Distribute the degrading electrons between those bins</span>
0329         <span class="comment">% (don't ask, figure it out for yourself if you really want</span>
0330         <span class="comment">% to know... ...I have sadly forgotten)</span>
0331         partition_fract(1) = min(1,<span class="keyword">...</span>
0332                                  (E(i_upper(1))+gradE(i_upper(1)) - <span class="keyword">...</span>
0333                                   (E(iE)-dE_i(idE,1)))/gradE(iE));
0334         <span class="keyword">if</span> length(i_upper)&gt;2
0335           partition_fract(2:end-1) = min(1,gradE(i_upper(2:end-1))/gradE(iE));
0336         <span class="keyword">end</span>
0337         partition_fract(end) =  min(1,<span class="keyword">...</span>
0338                                     (E(iE)+gradE(iE)-dE_i(idE,1) - <span class="keyword">...</span>
0339                                      E(i_upper(end)))/gradE(iE));
0340         <span class="keyword">if</span> i_upper(end) == iE
0341           partition_fract(end) = 0;
0342         <span class="keyword">end</span>
0343         partition_fract = partition_fract/sum(partition_fract);
0344         <span class="comment">% Calculate the flux of degrading electrons, sum of those</span>
0345         <span class="comment">% back-scattered, and those that scatter in the forward</span>
0346         <span class="comment">% direction:</span>
0347         <span class="keyword">for</span> i_u = find(partition_fract~=0),<span class="comment">%1:numel(i_upper),</span>
0348           deg_Ie(:,:,i_upper(i_u)) = ( deg_Ie(:,:,i_upper(i_u)) + <span class="keyword">...</span>
0349                                        max(0,Ie_degraded) * <span class="keyword">...</span>
0350                                        partition_fract(i_u) );
0351         <span class="keyword">end</span>
0352       <span class="keyword">end</span>
0353       
0354     <span class="keyword">end</span>
0355     <span class="comment">% What remains is the ionisation</span>
0356     <span class="comment">%idE = length(dE_i);</span>
0357     <span class="keyword">for</span> idE2 = idE:size(dE_i,1),
0358       
0359       E_p_d = -( E - ( E(iE)+gradE(iE) - dE_i(idE2,1) ) );
0360       <span class="comment">% Then take care of the ionisation</span>
0361       i_upper = find( E + gradE &gt; E(iE)-dE_i(idE2,1) &amp; <span class="keyword">...</span>
0362                       E &lt; E(iE)+gradE(iE)-dE_i(idE2,1) );<span class="comment">% &amp; ...</span>
0363       <span class="keyword">if</span> ( ~isempty(i_upper) &amp;&amp; i_upper(1) &lt; iE )
0364         <span class="comment">% Calculate the ionisation rate:</span>
0365         <span class="keyword">if</span> second_e_isotropic <span class="comment">% TODO: Insert proper 2nd-ary e</span>
0366                               <span class="comment">% production rates, direction for</span>
0367                               <span class="comment">% direction just as for elastic and</span>
0368                               <span class="comment">% inelastic collisions - except here</span>
0369                               <span class="comment">% we have to do it energy-by-energy/BG-20180921</span>
0370           Ionization = 0*Ie_zt;
0371           Ionizing = repmat(n_i,numel(c_o_mu),numel(t)).*(xs_i(idE2,iE) * Ie_zt);
0372           <span class="keyword">for</span> i_mu = numel(c_o_mu):-1:1,
0373             Ionization((1:nZ)+nZ*(i_mu-1),:) = max(0,<span class="keyword">...</span>
0374                                                    repmat(n_i,1,numel(t)).*(xs_i(idE2,iE) * Ie_zt((1:nZ)+nZ*(i_mu-1),:))*<span class="keyword">...</span>
0375                                                    BeamWeights(i_mu)/sum(BeamWeights));
0376           <span class="keyword">end</span>
0377         <span class="keyword">else</span>
0378           Ionizing   = max(0,<span class="keyword">...</span>
0379                            repmat(n_i,numel(c_o_mu),numel(t)).*(xs_i(idE2,iE) * Ie_zt));
0380           Ionization = max(0,<span class="keyword">...</span>
0381                            repmat(n_i,numel(c_o_mu),numel(t)).*(xs_i(idE2,iE) * Ie_zt));
0382         <span class="keyword">end</span>
0383         <span class="comment">% Calculate the spectra of the secondary electrons, using the</span>
0384         <span class="comment">% average energy of the electrons in the current energy bin:</span>
0385         second_e_spectra = feval(second_e_fcn,E,E(iE),dE_i(idE2,1),<span class="string">'s'</span>);
0386         second_e_spectra = (second_e_spectra + second_e_spectra([2:end end]))/2.*gradE;
0387         <span class="comment">% And the distribution of the ionising electrons (that have</span>
0388         <span class="comment">% to lose the corresponding amount of energy)</span>
0389         <span class="comment">% deg_sp = abs(feval(second_e_fcn,max(1,min(( E(iE) - dE_i(idE2,1) )/2,max(0,E_p_d))),E(iE),3));</span>
0390         deg_sp = second_e_fcn(E,E(iE),dE_i(idE2,1),<span class="string">'c'</span>);
0391         
0392         <span class="keyword">if</span> sum(second_e_spectra) &gt; 0
0393           <span class="comment">% Multiply with the number of electrons created - double</span>
0394           <span class="comment">% ionization, double dissociative ionization gives two...</span>
0395           second_e_spectra = dE_i(idE2,2)*second_e_spectra/(sum(second_e_spectra));
0396         <span class="keyword">end</span>
0397         <span class="keyword">if</span> sum(deg_sp) &gt; 0
0398           deg_sp = deg_sp/sum(deg_sp);
0399         <span class="keyword">end</span>
0400         
0401         <span class="comment">% TODO: Check that the sum of s_e_s and deg_Sp are the same</span>
0402         e_ionized_distribution = max(second_e_spectra,deg_sp); <span class="comment">% or just sum</span>
0403         e_ionized_distribution(~isfinite(e_ionized_distribution)) = 0;
0404         
0405         <span class="comment">% and add this to the degrading electron fluxes, here there</span>
0406         <span class="comment">% should be &quot;no&quot; angular-scattering:</span>
0407         <span class="comment">% This part should be possible to move out of the loop over</span>
0408         <span class="comment">% the species</span>
0409         <span class="comment">% TODO: insert the corresponding angular scattering for</span>
0410         <span class="comment">% ionizing primary electrons here!/BG-20180921</span>
0411         <span class="keyword">for</span> iI = 1:iE-1,
0412           deg_Ie(:,:,iI) = ( deg_Ie(:,:,iI) + <span class="keyword">...</span>
0413                              Ionization*second_e_spectra(iI) +<span class="keyword">...</span><span class="comment"> % Isotropic secondaries</span>
0414                              Ionizing*deg_sp(iI) ); <span class="comment">% Forward-scattering primary-e</span>
0415           <span class="keyword">if</span> e_ionized_distribution(iI) == 0
0416             <span class="keyword">break</span>
0417           <span class="keyword">end</span>
0418         <span class="keyword">end</span>
0419         <span class="comment">%         for iti = numel(t):-1:1,</span>
0420         <span class="comment">%           deg_Ie(:,iti,:) = squeeze(deg_Ie(:,iti,:)) + dE_i(idE2,2)*Ionization(:,iti)*e_ionized_distribution;</span>
0421         <span class="comment">%         end</span>
0422         <span class="comment">%        for izi = size(Ionization,1):-1:1,</span>
0423         <span class="comment">%          deg_Ie(izi,:,:) = squeeze(deg_Ie(izi,:,:)) + dE_i(idE2,2)*Ionization(izi,:)'*e_ionized_distribution;</span>
0424         <span class="comment">%        end</span>
0425       <span class="keyword">end</span>
0426     <span class="keyword">end</span>
0427     
0428   <span class="keyword">end</span>
0429   <span class="keyword">try</span>
0430     load(<span class="string">'stopnow.dat'</span>)
0431     <span class="keyword">if</span> stopnow == 1 || stopnow==iE
0432       keyboard
0433     <span class="keyword">end</span>
0434   <span class="keyword">catch</span>
0435   <span class="keyword">end</span>
0436   <span class="comment">% waitbar((length(E)-iE)/length(E),wbh);</span>
0437   
0438 <span class="keyword">end</span>
0439 
0440 <span class="comment">% try</span>
0441 <span class="comment">%   close(wbh)</span>
0442 <span class="comment">% catch</span>
0443 <span class="comment">% end</span>
0444</pre></div>
<hr><address>Generated on Mon 18-Nov-2019 14:53:30 by <strong>B.&nbsp;Gustavsson</strong> with <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2003</address>
</body>
</html>