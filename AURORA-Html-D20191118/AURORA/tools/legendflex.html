<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of legendflex</title>
  <meta name="keywords" content="legendflex">
  <meta name="description" content="LEGENDFLEX Creates a more flexible legend">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html AURORA --><!-- menu.html tools -->
<h1>legendflex
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>LEGENDFLEX Creates a more flexible legend</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function varargout = legendflex(varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">LEGENDFLEX Creates a more flexible legend

 legendflex(M, param1, val1, ...)
 legendflex(h, M, param1, val1, ...)
 [legend_h,object_h,plot_h,text_str] = legendflex(...)
 
 This offers a more flexible version of the legend command.  It offers a
 different method of positioning the legend, as well as options to:

   - organize legend text and symbols in a grid with a specified number of
     rows and/or columns 
   - rescale the horizontal space used by each legend symbol
   - create multiple legends for the same axis
   - add a title to the legend within the legend box

 Unlike in the default legend command, where the legend is positioned
 relative to the labeled objects' parent axis according to one of 16
 location strings, this function positions the legend based on two anchor
 points (one on either the figure or a child object of a figure, and one
 on the legend itself) and a buffer (or offset) between these two anchor
 points. The anchor points refer to the corners and centers of each
 side of the box surrounding the reference object and the legend itself;
 they can be refered to either as numbers (1-8, clockwise from northwest
 corner) or strings ('nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w').  The
 position of the legend is determined by these two points and the distance
 between them, defined in the 'buffer' variable, which by default is
 measured in pixels.  So the combination of
 
  (..., 'ref', gca, 'anchor', [3 3], 'buffer', [-10 -10])

 means that you want the northeast corner of the current axis to be
 aligned with the northeast corner of the legend, but with the legend
 shifted 10 pixels to the left and down. 

 This method of positioning can be particularly useful when labeling a
 figure that includes many subplots that share a common color scheme,
 where the &quot;best&quot; location for a legend is not necessarily within the
 bounds of an axis.  Unlike the legend command, the axes in the figure are
 never resized (and it is up to the user to check that the legend fits on
 the figure in the specified location).  In addition to being easier than
 manually positioning a legend, this function updates the legend location
 when the figure is resized, preserving the desired alignment.  The
 following anchor/buffer combinations, when used with the default
 reference and a buffer unit of pixels, approximately replicate the
 typical legend locations:

 Specifier              Anchor    Buffer
 
 north                  [2 2]     [  0 -10]
 south                  [6 6]     [  0  10]
 east                   [4 4]     [-10   0]
 west                   [8 8]     [ 10   0]
 northeast              [3 3]     [-10 -10]
 northwest              [1 1]     [ 10 -10]
 southeast              [5 5]     [-10  10]
 southwest              [7 7]     [ 10  10]
 northoutside*          [2 6]     [  0  10]
 southoutside*          [6 2]     [  0 -10]
 eastoutside*           [3 8]     [ 10   0]
 westoutside*           [8 3]     [-10   0]
 northeastoutside*      [3 1]     [ 10   0]
 northwestoutside*      [1 3]     [-10   0]
 southeastoutside*      [5 7]     [ 10   0]
 southwestoutside*      [7 5]     [-10   0]  *placed outside axis rather
                                              than resizing plot box

 This function should support all types of plot objects.

 A note on resizing: This function assigns a resize function to the parent
 figure to maintain the position of the legend (in terms of anchor
 location and buffer) as the figure size changes.  If you manually resize
 the legend, this function will respect changes to height, width, and
 units (though I don't recommend changing the units to 'normalized', as
 this can cause the text and symbols to overflow the legend box on
 resize).  It will not respect manual repositioning when resizing, since
 it assumes you want to maintain the anchor/buffer prescription used to
 create it.  Overall, I've tried to make this resize as unobtrusive as
 possible; if your figure already has a resize function at the time you
 apply it, that behavior is inherited, with the legend-resize called
 afterward.  If you plan to further modify the figure's resize function
 post-legendflex and want to maintain repositioning of the legends,
 retrieve the resize function via hfun = get(hfig, 'ResizeFcn'), pass it
 to the new resize function, and invoke it via feval(oldfun, h, ed), where
 h and ed are the default variables passed by a callback function.

 Input variables:

   M:          cell array of strings, labels for legend

   h:          handle of axis or handle(s) of object(s) to be labeled.  If
               this is an axis handle, all children of the axis will be
               included in the legend.  If not included, current axis is
               used.

 Optional input variables (passed as parameter/value pairs): [default]

   ncol:       number of columns, or NaN to indicate as many as necessary
               given the # of labeled objects [1 if nrow is NaN, NaN
               otherwise] 

   nrow:       number of rows, or NaN to indicate as many as necessary
               given the # of labeled objects [NaN]

   ref:        handle of object used to position the legend. This can be
               either a figure or a child object of a figure (and does not
               need to relate in any way to the objects being labeled).
               If not included, the reference will be to the axis that a
               normal legend would be associated with (usually the parent
               axis of the labeled objects, unless objects from multiple
               axes are passed, in which case it's the parent object of
               the first labeled object).

   anchor:     1 x 2 array specifying which points of the reference object
               and new legend, respectively, to anchor to each other.
               Anchor points can be described using either numbers (in a 1
               x 2 double array) or directional strings (in a 1 x 2 cell
               array) as follows:
               1:  'nw'    upper left corner
               2:  'n'     center of top edge
               3:  'ne'    upper right corner
               4:  'e'     center of right edge
               5:  'se'    bottom right corner
               6:  's'     center of bottom edge
               7:  'sw'    bottom left corner
               8:  'w'     center of left edge         

               [[3 3], i.e. {'ne' 'ne'}]

   buffer:     1 x 2 array of horizontal and vertical distance,
               respectively, from the reference anchor point to the legend
               anchor point. Distance is measured in units specified by
               bufferunit. [[-10 -10]]
               
   bufferunit: unit for buffer distance.  Note that this property only
               affects the units used to position the legend, not the
               units for the legend itself (which is always a fixed size,
               based on the space needed to encapsulate the specified
               symbols and text).  The 'normalized' units are normalized
               to size of the figure. ['pixels']   

   box:        'on' or 'off', specifies whether to enclose legend objects
               in a box ['on']

   xscale:     scalar value indicating scale factor to apply to the width
               required by each symbol, relative to the size used by
               legend. For example, 0.5 will shorten the lines/patches by
               half. [1]

   title:      A title string to be added inside the legend box, centered,
               above all legend entries.  This can be either a string or a
               cell array of strings; the latter will produce a multi-line
               title. If empty, no title is added.  ['']

   In addition to these legendflex-specific parameters, this function will
   accept any parameter accepted by the original legend function (e.g.
   font properties) except 'location', 'boxon', 'boxoff', or 'hide'.

 Output variables:

   legend_h:   handle of the legend axis.  It is not linked to an axis or
               graphics objects in the same way as a Matlab legend.
               However, on figure resize, all properties of the legend
               objects are checked for changes, so adjusting the figure
               size can re-link the legend to the labeled objects after
               you have made changes to those objects.
 
   object_h:   handles of the line, patch, and text graphics objects
               created in the legend 
 
   plot_h:     handles of the lines and other objects labeled in this
               legend
 
   text_str:   cell array of the text strings used in the legend


 Example:

 % Replicating an example from legend.m:

 figure;
 b = bar(rand(10,5),'stacked'); colormap(summer); hold on
 x = plot(1:10,5*rand(10,1),'marker','square','markersize',12,...
          'markeredgecolor','y','markerfacecolor',[.6 0 .6],...
          'linestyle','-','color','r','linewidth',2); hold off
 lbl = {'Carrots','Peas','Peppers','Green Beans','Cucumbers','Eggplant'};

 % Rather than covering up data or resizing the axis, let's squeeze the
 % legend into the margin at the top of the figure;

 legendflex([b,x], lbl, 'ref', gcf, ...
                        'anchor', {'n','n'}, ...
                        'buffer',[0 0], ...
                        'nrow',2, ...
                        'fontsize',8);</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="getpos.html" class="code" title="function [pos,unit]=getpos(h,fmt,href,opt)">getpos</a>	GETPOS Get graphics object position in a flexible way.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../AURORA/setup4etrptd10streams.html" class="code" title="">setup4etrptd10streams</a>	% Set-up script for Examples in time-dependent electron transport</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function legpos = positionleg(href, w, h, anchor, buffer, bufunit)</a></li><li><a href="#_sub2" class="code">function resizefig(hfig, ed, oldrsz)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function varargout = legendflex(varargin)</a>
0002 <span class="comment">%LEGENDFLEX Creates a more flexible legend</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% legendflex(M, param1, val1, ...)</span>
0005 <span class="comment">% legendflex(h, M, param1, val1, ...)</span>
0006 <span class="comment">% [legend_h,object_h,plot_h,text_str] = legendflex(...)</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% This offers a more flexible version of the legend command.  It offers a</span>
0009 <span class="comment">% different method of positioning the legend, as well as options to:</span>
0010 <span class="comment">%</span>
0011 <span class="comment">%   - organize legend text and symbols in a grid with a specified number of</span>
0012 <span class="comment">%     rows and/or columns</span>
0013 <span class="comment">%   - rescale the horizontal space used by each legend symbol</span>
0014 <span class="comment">%   - create multiple legends for the same axis</span>
0015 <span class="comment">%   - add a title to the legend within the legend box</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% Unlike in the default legend command, where the legend is positioned</span>
0018 <span class="comment">% relative to the labeled objects' parent axis according to one of 16</span>
0019 <span class="comment">% location strings, this function positions the legend based on two anchor</span>
0020 <span class="comment">% points (one on either the figure or a child object of a figure, and one</span>
0021 <span class="comment">% on the legend itself) and a buffer (or offset) between these two anchor</span>
0022 <span class="comment">% points. The anchor points refer to the corners and centers of each</span>
0023 <span class="comment">% side of the box surrounding the reference object and the legend itself;</span>
0024 <span class="comment">% they can be refered to either as numbers (1-8, clockwise from northwest</span>
0025 <span class="comment">% corner) or strings ('nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w').  The</span>
0026 <span class="comment">% position of the legend is determined by these two points and the distance</span>
0027 <span class="comment">% between them, defined in the 'buffer' variable, which by default is</span>
0028 <span class="comment">% measured in pixels.  So the combination of</span>
0029 <span class="comment">%</span>
0030 <span class="comment">%  (..., 'ref', gca, 'anchor', [3 3], 'buffer', [-10 -10])</span>
0031 <span class="comment">%</span>
0032 <span class="comment">% means that you want the northeast corner of the current axis to be</span>
0033 <span class="comment">% aligned with the northeast corner of the legend, but with the legend</span>
0034 <span class="comment">% shifted 10 pixels to the left and down.</span>
0035 <span class="comment">%</span>
0036 <span class="comment">% This method of positioning can be particularly useful when labeling a</span>
0037 <span class="comment">% figure that includes many subplots that share a common color scheme,</span>
0038 <span class="comment">% where the &quot;best&quot; location for a legend is not necessarily within the</span>
0039 <span class="comment">% bounds of an axis.  Unlike the legend command, the axes in the figure are</span>
0040 <span class="comment">% never resized (and it is up to the user to check that the legend fits on</span>
0041 <span class="comment">% the figure in the specified location).  In addition to being easier than</span>
0042 <span class="comment">% manually positioning a legend, this function updates the legend location</span>
0043 <span class="comment">% when the figure is resized, preserving the desired alignment.  The</span>
0044 <span class="comment">% following anchor/buffer combinations, when used with the default</span>
0045 <span class="comment">% reference and a buffer unit of pixels, approximately replicate the</span>
0046 <span class="comment">% typical legend locations:</span>
0047 <span class="comment">%</span>
0048 <span class="comment">% Specifier              Anchor    Buffer</span>
0049 <span class="comment">%</span>
0050 <span class="comment">% north                  [2 2]     [  0 -10]</span>
0051 <span class="comment">% south                  [6 6]     [  0  10]</span>
0052 <span class="comment">% east                   [4 4]     [-10   0]</span>
0053 <span class="comment">% west                   [8 8]     [ 10   0]</span>
0054 <span class="comment">% northeast              [3 3]     [-10 -10]</span>
0055 <span class="comment">% northwest              [1 1]     [ 10 -10]</span>
0056 <span class="comment">% southeast              [5 5]     [-10  10]</span>
0057 <span class="comment">% southwest              [7 7]     [ 10  10]</span>
0058 <span class="comment">% northoutside*          [2 6]     [  0  10]</span>
0059 <span class="comment">% southoutside*          [6 2]     [  0 -10]</span>
0060 <span class="comment">% eastoutside*           [3 8]     [ 10   0]</span>
0061 <span class="comment">% westoutside*           [8 3]     [-10   0]</span>
0062 <span class="comment">% northeastoutside*      [3 1]     [ 10   0]</span>
0063 <span class="comment">% northwestoutside*      [1 3]     [-10   0]</span>
0064 <span class="comment">% southeastoutside*      [5 7]     [ 10   0]</span>
0065 <span class="comment">% southwestoutside*      [7 5]     [-10   0]  *placed outside axis rather</span>
0066 <span class="comment">%                                              than resizing plot box</span>
0067 <span class="comment">%</span>
0068 <span class="comment">% This function should support all types of plot objects.</span>
0069 <span class="comment">%</span>
0070 <span class="comment">% A note on resizing: This function assigns a resize function to the parent</span>
0071 <span class="comment">% figure to maintain the position of the legend (in terms of anchor</span>
0072 <span class="comment">% location and buffer) as the figure size changes.  If you manually resize</span>
0073 <span class="comment">% the legend, this function will respect changes to height, width, and</span>
0074 <span class="comment">% units (though I don't recommend changing the units to 'normalized', as</span>
0075 <span class="comment">% this can cause the text and symbols to overflow the legend box on</span>
0076 <span class="comment">% resize).  It will not respect manual repositioning when resizing, since</span>
0077 <span class="comment">% it assumes you want to maintain the anchor/buffer prescription used to</span>
0078 <span class="comment">% create it.  Overall, I've tried to make this resize as unobtrusive as</span>
0079 <span class="comment">% possible; if your figure already has a resize function at the time you</span>
0080 <span class="comment">% apply it, that behavior is inherited, with the legend-resize called</span>
0081 <span class="comment">% afterward.  If you plan to further modify the figure's resize function</span>
0082 <span class="comment">% post-legendflex and want to maintain repositioning of the legends,</span>
0083 <span class="comment">% retrieve the resize function via hfun = get(hfig, 'ResizeFcn'), pass it</span>
0084 <span class="comment">% to the new resize function, and invoke it via feval(oldfun, h, ed), where</span>
0085 <span class="comment">% h and ed are the default variables passed by a callback function.</span>
0086 <span class="comment">%</span>
0087 <span class="comment">% Input variables:</span>
0088 <span class="comment">%</span>
0089 <span class="comment">%   M:          cell array of strings, labels for legend</span>
0090 <span class="comment">%</span>
0091 <span class="comment">%   h:          handle of axis or handle(s) of object(s) to be labeled.  If</span>
0092 <span class="comment">%               this is an axis handle, all children of the axis will be</span>
0093 <span class="comment">%               included in the legend.  If not included, current axis is</span>
0094 <span class="comment">%               used.</span>
0095 <span class="comment">%</span>
0096 <span class="comment">% Optional input variables (passed as parameter/value pairs): [default]</span>
0097 <span class="comment">%</span>
0098 <span class="comment">%   ncol:       number of columns, or NaN to indicate as many as necessary</span>
0099 <span class="comment">%               given the # of labeled objects [1 if nrow is NaN, NaN</span>
0100 <span class="comment">%               otherwise]</span>
0101 <span class="comment">%</span>
0102 <span class="comment">%   nrow:       number of rows, or NaN to indicate as many as necessary</span>
0103 <span class="comment">%               given the # of labeled objects [NaN]</span>
0104 <span class="comment">%</span>
0105 <span class="comment">%   ref:        handle of object used to position the legend. This can be</span>
0106 <span class="comment">%               either a figure or a child object of a figure (and does not</span>
0107 <span class="comment">%               need to relate in any way to the objects being labeled).</span>
0108 <span class="comment">%               If not included, the reference will be to the axis that a</span>
0109 <span class="comment">%               normal legend would be associated with (usually the parent</span>
0110 <span class="comment">%               axis of the labeled objects, unless objects from multiple</span>
0111 <span class="comment">%               axes are passed, in which case it's the parent object of</span>
0112 <span class="comment">%               the first labeled object).</span>
0113 <span class="comment">%</span>
0114 <span class="comment">%   anchor:     1 x 2 array specifying which points of the reference object</span>
0115 <span class="comment">%               and new legend, respectively, to anchor to each other.</span>
0116 <span class="comment">%               Anchor points can be described using either numbers (in a 1</span>
0117 <span class="comment">%               x 2 double array) or directional strings (in a 1 x 2 cell</span>
0118 <span class="comment">%               array) as follows:</span>
0119 <span class="comment">%               1:  'nw'    upper left corner</span>
0120 <span class="comment">%               2:  'n'     center of top edge</span>
0121 <span class="comment">%               3:  'ne'    upper right corner</span>
0122 <span class="comment">%               4:  'e'     center of right edge</span>
0123 <span class="comment">%               5:  'se'    bottom right corner</span>
0124 <span class="comment">%               6:  's'     center of bottom edge</span>
0125 <span class="comment">%               7:  'sw'    bottom left corner</span>
0126 <span class="comment">%               8:  'w'     center of left edge</span>
0127 <span class="comment">%</span>
0128 <span class="comment">%               [[3 3], i.e. {'ne' 'ne'}]</span>
0129 <span class="comment">%</span>
0130 <span class="comment">%   buffer:     1 x 2 array of horizontal and vertical distance,</span>
0131 <span class="comment">%               respectively, from the reference anchor point to the legend</span>
0132 <span class="comment">%               anchor point. Distance is measured in units specified by</span>
0133 <span class="comment">%               bufferunit. [[-10 -10]]</span>
0134 <span class="comment">%</span>
0135 <span class="comment">%   bufferunit: unit for buffer distance.  Note that this property only</span>
0136 <span class="comment">%               affects the units used to position the legend, not the</span>
0137 <span class="comment">%               units for the legend itself (which is always a fixed size,</span>
0138 <span class="comment">%               based on the space needed to encapsulate the specified</span>
0139 <span class="comment">%               symbols and text).  The 'normalized' units are normalized</span>
0140 <span class="comment">%               to size of the figure. ['pixels']</span>
0141 <span class="comment">%</span>
0142 <span class="comment">%   box:        'on' or 'off', specifies whether to enclose legend objects</span>
0143 <span class="comment">%               in a box ['on']</span>
0144 <span class="comment">%</span>
0145 <span class="comment">%   xscale:     scalar value indicating scale factor to apply to the width</span>
0146 <span class="comment">%               required by each symbol, relative to the size used by</span>
0147 <span class="comment">%               legend. For example, 0.5 will shorten the lines/patches by</span>
0148 <span class="comment">%               half. [1]</span>
0149 <span class="comment">%</span>
0150 <span class="comment">%   title:      A title string to be added inside the legend box, centered,</span>
0151 <span class="comment">%               above all legend entries.  This can be either a string or a</span>
0152 <span class="comment">%               cell array of strings; the latter will produce a multi-line</span>
0153 <span class="comment">%               title. If empty, no title is added.  ['']</span>
0154 <span class="comment">%</span>
0155 <span class="comment">%   In addition to these legendflex-specific parameters, this function will</span>
0156 <span class="comment">%   accept any parameter accepted by the original legend function (e.g.</span>
0157 <span class="comment">%   font properties) except 'location', 'boxon', 'boxoff', or 'hide'.</span>
0158 <span class="comment">%</span>
0159 <span class="comment">% Output variables:</span>
0160 <span class="comment">%</span>
0161 <span class="comment">%   legend_h:   handle of the legend axis.  It is not linked to an axis or</span>
0162 <span class="comment">%               graphics objects in the same way as a Matlab legend.</span>
0163 <span class="comment">%               However, on figure resize, all properties of the legend</span>
0164 <span class="comment">%               objects are checked for changes, so adjusting the figure</span>
0165 <span class="comment">%               size can re-link the legend to the labeled objects after</span>
0166 <span class="comment">%               you have made changes to those objects.</span>
0167 <span class="comment">%</span>
0168 <span class="comment">%   object_h:   handles of the line, patch, and text graphics objects</span>
0169 <span class="comment">%               created in the legend</span>
0170 <span class="comment">%</span>
0171 <span class="comment">%   plot_h:     handles of the lines and other objects labeled in this</span>
0172 <span class="comment">%               legend</span>
0173 <span class="comment">%</span>
0174 <span class="comment">%   text_str:   cell array of the text strings used in the legend</span>
0175 <span class="comment">%</span>
0176 <span class="comment">%</span>
0177 <span class="comment">% Example:</span>
0178 <span class="comment">%</span>
0179 <span class="comment">% % Replicating an example from legend.m:</span>
0180 <span class="comment">%</span>
0181 <span class="comment">% figure;</span>
0182 <span class="comment">% b = bar(rand(10,5),'stacked'); colormap(summer); hold on</span>
0183 <span class="comment">% x = plot(1:10,5*rand(10,1),'marker','square','markersize',12,...</span>
0184 <span class="comment">%          'markeredgecolor','y','markerfacecolor',[.6 0 .6],...</span>
0185 <span class="comment">%          'linestyle','-','color','r','linewidth',2); hold off</span>
0186 <span class="comment">% lbl = {'Carrots','Peas','Peppers','Green Beans','Cucumbers','Eggplant'};</span>
0187 <span class="comment">%</span>
0188 <span class="comment">% % Rather than covering up data or resizing the axis, let's squeeze the</span>
0189 <span class="comment">% % legend into the margin at the top of the figure;</span>
0190 <span class="comment">%</span>
0191 <span class="comment">% legendflex([b,x], lbl, 'ref', gcf, ...</span>
0192 <span class="comment">%                        'anchor', {'n','n'}, ...</span>
0193 <span class="comment">%                        'buffer',[0 0], ...</span>
0194 <span class="comment">%                        'nrow',2, ...</span>
0195 <span class="comment">%                        'fontsize',8);</span>
0196 
0197 <span class="comment">% Copyright 2011 Kelly Kearney</span>
0198 
0199 
0200 <span class="comment">%-------------------</span>
0201 <span class="comment">% Parse input</span>
0202 <span class="comment">%-------------------</span>
0203 
0204 allinput = varargin; <span class="comment">% Save for callback later</span>
0205 
0206 islegin = false(size(varargin));
0207 
0208 <span class="comment">% First inputs must be either:</span>
0209 <span class="comment">% (M, ...)</span>
0210 <span class="comment">% (h, M, ...)</span>
0211 
0212 <span class="comment">% Look for handle array</span>
0213 
0214 <span class="comment">% BG20180926-4m2105b handlepassed = isnumeric(varargin{1}) &amp; all(ishandle(varargin{1}));</span>
0215 handlepassed = all(ishandle(varargin{1}));
0216 
0217 <span class="keyword">if</span> handlepassed
0218     legin = varargin(1:2);
0219     <span class="keyword">if</span> ~iscell(legin{2}) || ~all(cellfun(@ischar, legin{2}))
0220         error(<span class="string">'Legend labels must be a cell array of strings'</span>);
0221     <span class="keyword">end</span>
0222     pv = varargin(3:end);
0223 <span class="keyword">else</span>
0224     legin = varargin(1);
0225     <span class="keyword">if</span> ~iscell(legin{1}) || ~all(cellfun(@ischar, legin{1}))
0226         <span class="keyword">if</span> isnumeric(legin{1})
0227             error(<span class="string">'Unable to parse input 1; check that handle(s) exist'</span>);
0228         <span class="keyword">else</span>
0229             error(<span class="string">'Legend labels must be a cell array of strings'</span>);
0230         <span class="keyword">end</span>
0231     <span class="keyword">end</span>
0232     pv = varargin(2:end);
0233 <span class="keyword">end</span>
0234 
0235 <span class="comment">% Parse my optional properties</span>
0236 
0237 p = inputParser;
0238 p.addParamValue(<span class="string">'xscale'</span>,     1,         @(x) validateattributes(x, {<span class="string">'numeric'</span>}, {<span class="string">'nonnegative'</span>,<span class="string">'scalar'</span>}));
0239 p.addParamValue(<span class="string">'ncol'</span>,       NaN,       @(x) validateattributes(x, {<span class="string">'numeric'</span>}, {<span class="string">'scalar'</span>, <span class="string">'integer'</span>}));
0240 p.addParamValue(<span class="string">'nrow'</span>,       NaN,       @(x) validateattributes(x, {<span class="string">'numeric'</span>}, {<span class="string">'scalar'</span>, <span class="string">'integer'</span>}));
0241 p.addParamValue(<span class="string">'ref'</span>,        NaN,       @(x) validateattributes(x, {<span class="string">'numeric'</span>}, {<span class="string">'scalar'</span>}));
0242 p.addParamValue(<span class="string">'anchor'</span>,     [3 3],     @(x) validateattributes(x, {<span class="string">'numeric'</span>,<span class="string">'cell'</span>}, {<span class="string">'size'</span>, [1 2]}));
0243 p.addParamValue(<span class="string">'buffer'</span>,     [-10 -10], @(x) validateattributes(x, {<span class="string">'numeric'</span>}, {<span class="string">'size'</span>, [1 2]}));
0244 p.addParamValue(<span class="string">'bufferunit'</span>, <span class="string">'pixels'</span>,  @(x) validateattributes(x, {<span class="string">'char'</span>}, {}));
0245 p.addParamValue(<span class="string">'box'</span>,        <span class="string">'on'</span>,      @(x) validateattributes(x, {<span class="string">'char'</span>}, {}));
0246 p.addParamValue(<span class="string">'title'</span>,      <span class="string">''</span>,        @(x) validateattributes(x, {<span class="string">'char'</span>,<span class="string">'cell'</span>}, {}));
0247 
0248 p.KeepUnmatched = true;
0249 
0250 p.parse(pv{:});
0251 Opt = p.Results;
0252 
0253 <span class="comment">% Any parameters that don't match mine are assumed to be a legend property.</span>
0254 <span class="comment">%  If not, legend will handle the error when I call it.</span>
0255 
0256 Extra = p.Unmatched;
0257 extra = [fieldnames(Extra) struct2cell(Extra)];
0258 extra = extra';
0259 
0260 <span class="comment">% Validate that units and box inputs are correct</span>
0261 
0262 validatestring(Opt.bufferunit, {<span class="string">'pixels'</span>,<span class="string">'normalized'</span>,<span class="string">'inches'</span>,<span class="string">'centimeters'</span>,<span class="string">'points'</span>,<span class="string">'characters'</span>}, <span class="string">'legendflex'</span>, <span class="string">'bufferunit'</span>);
0263 validatestring(Opt.box, {<span class="string">'on'</span>, <span class="string">'off'</span>}, <span class="string">'legendflex'</span>, <span class="string">'box'</span>);
0264 
0265 <span class="comment">% Translate anchor strings to numbers, if necessary</span>
0266 
0267 <span class="keyword">if</span> iscell(Opt.anchor)
0268     [blah, Opt.anchor] = ismember(Opt.anchor, {<span class="string">'nw'</span>,<span class="string">'n'</span>,<span class="string">'ne'</span>,<span class="string">'e'</span>,<span class="string">'se'</span>,<span class="string">'s'</span>,<span class="string">'sw'</span>,<span class="string">'w'</span>});
0269     <span class="keyword">if</span> ~all(blah)
0270         error(<span class="string">'Anchor must be 1 x 2 cell array of strings: n, e, s, w, ne, nw, se, sw'</span>);
0271     <span class="keyword">end</span>
0272 <span class="keyword">else</span>
0273     validateattributes(Opt.anchor, {<span class="string">'numeric'</span>}, {<span class="string">'integer'</span>, <span class="string">'&lt;='</span>, 8}, <span class="string">'legendflex'</span>, <span class="string">'anchor'</span>);
0274 <span class="keyword">end</span>
0275 
0276 <span class="comment">% Create a temporary legend to get all the objects</span>
0277 
0278 S = warning(<span class="string">'off'</span>, <span class="string">'MATLAB:legend:PlotEmpty'</span>);
0279 [h.leg, h.obj, h.labeledobj, h.textstr] = legend(legin{:}, extra{:}, <span class="string">'location'</span>, <span class="string">'northeast'</span>);
0280 nobj = length(h.labeledobj);
0281 warning(S);
0282 
0283 <span class="keyword">if</span> nobj == 0
0284     warning(<span class="string">'Plot empty; no legend created'</span>);
0285     <span class="keyword">return</span>
0286 <span class="keyword">end</span>
0287 
0288 <span class="keyword">if</span> ~handlepassed <span class="comment">% For figure resize, can't assume the current axis will still be current</span>
0289     tmp = get(h.leg, <span class="string">'UserData'</span>);
0290     allinput = [{tmp.PlotHandle} allinput];
0291 <span class="keyword">end</span>
0292 
0293 <span class="comment">% # rows and columns</span>
0294 
0295 <span class="keyword">if</span> isnan(Opt.ncol) &amp;&amp; isnan(Opt.nrow)
0296     Opt.ncol = 1;
0297     Opt.nrow = nobj;
0298 <span class="keyword">elseif</span> isnan(Opt.ncol)
0299     Opt.ncol = ceil(nobj./Opt.nrow);
0300 <span class="keyword">elseif</span> isnan(Opt.nrow)
0301     Opt.nrow = ceil(nobj./Opt.ncol);
0302 <span class="keyword">end</span>
0303 <span class="keyword">if</span> Opt.ncol*Opt.nrow &lt; nobj
0304     error(<span class="string">'Number of legend entries greater than specified grid allows; change ncol and/or nrow'</span>);
0305 <span class="keyword">end</span>
0306 
0307 <span class="comment">% Reference object</span>
0308 
0309 <span class="keyword">if</span> isnan(Opt.ref)
0310     tmp = get(h.leg, <span class="string">'UserData'</span>);
0311     Opt.ref = tmp.PlotHandle;
0312 <span class="keyword">end</span>
0313 <span class="keyword">if</span> ~ishandle(Opt.ref)
0314     error(<span class="string">'Input ref must be a graphics handle'</span>);
0315 <span class="keyword">end</span>
0316 
0317 <span class="comment">% Box</span>
0318 
0319 Opt.box = strcmpi(<span class="string">'on'</span>, Opt.box);
0320 
0321 <span class="comment">% Convert units to getpos abbreviations</span>
0322 
0323 unittable = {<span class="keyword">...</span>
0324     <span class="string">'px'</span>  <span class="string">'Pixels'</span>
0325     <span class="string">'nz'</span>  <span class="string">'Normalized'</span>
0326     <span class="string">'in'</span>  <span class="string">'Inches'</span>
0327     <span class="string">'cm'</span>  <span class="string">'Centimeters'</span>
0328     <span class="string">'pt'</span>  <span class="string">'Points'</span>
0329     <span class="string">'ch'</span>  <span class="string">'Characters'</span>};
0330 Opt.bufunit = unittable{strcmpi(unittable(:,2),Opt.bufferunit),1};
0331 
0332 <span class="comment">% Check for title</span>
0333 
0334 addtitle = ~isempty(Opt.title);
0335 
0336 <span class="comment">%-------------------</span>
0337 <span class="comment">% New placement of</span>
0338 <span class="comment">% everything in</span>
0339 <span class="comment">% legend</span>
0340 <span class="comment">%-------------------</span>
0341 
0342 <span class="comment">% Determine parent figure</span>
0343 
0344 figh = ancestor(Opt.ref, <span class="string">'figure'</span>);
0345 currax = get(figh, <span class="string">'currentaxes'</span>); 
0346 
0347 <span class="comment">% Calculate row height</span>
0348 
0349 legpospx = <a href="getpos.html" class="code" title="function [pos,unit]=getpos(h,fmt,href,opt)">getpos</a>(h.leg, <span class="string">'px'</span>);
0350 
0351 <span class="comment">% rowHeight = legpospx(4)/nobj;</span>
0352 vmarginNm =  0.275/nobj;
0353 vmarginPx = legpospx(4) * vmarginNm;
0354 
0355 rowHeightNm = (1 - vmarginNm)/nobj;
0356 rowHeight = rowHeightNm .* legpospx(4);
0357 
0358 <span class="comment">% Determine width needed for each text string</span>
0359 
0360 <span class="keyword">if</span> nobj == 1
0361     textExtent = get(h.obj(1:nobj), <span class="string">'Extent'</span>);
0362 <span class="keyword">else</span>
0363     textExtent = cell2mat(get(h.obj(1:nobj), <span class="string">'Extent'</span>));
0364 <span class="keyword">end</span>
0365 textWidthPx  = textExtent(:,3) .* legpospx(3);
0366 textHeightPx = textExtent(:,4) .* legpospx(4);
0367 textWidthNm = textExtent(:,3);
0368 
0369 <span class="comment">% Calculate horizontal space needed for symbols</span>
0370 
0371 symbolWidthPx = textExtent(1,1) .* legpospx(3) * Opt.xscale;
0372 symbolWidthNm = textExtent(1,1);
0373 
0374 <span class="comment">% Calculate column width needed for 2px-symbol-1px-text-1px</span>
0375 
0376 colWidth = zeros(Opt.ncol*Opt.nrow,1);
0377 colWidth(1:nobj) = textWidthPx + symbolWidthPx + 4;
0378 colWidth = reshape(colWidth, Opt.nrow, Opt.ncol);
0379 colWidth = max(colWidth,[],1);
0380 
0381 <span class="comment">% If title is added, figure out how much space it will need</span>
0382 
0383 <span class="keyword">if</span> addtitle
0384     textProps = {<span class="string">'FontAngle'</span>,<span class="string">'FontName'</span>,<span class="string">'FontSize'</span>,<span class="string">'FontUnits'</span>,<span class="string">'FontWeight'</span>,<span class="string">'Interpreter'</span>};
0385     textVals = get(h.obj(1), textProps);
0386     ttlprops = [textProps; textVals];
0387     
0388     fpos = <a href="getpos.html" class="code" title="function [pos,unit]=getpos(h,fmt,href,opt)">getpos</a>(figh, <span class="string">'px'</span>);
0389     figtmp = figure(<span class="string">'units'</span>,<span class="string">'pixels'</span>,<span class="string">'position'</span>,[0 0 fpos(3:4)],<span class="string">'visible'</span>,<span class="string">'off'</span>);
0390     axes(<span class="string">'parent'</span>,figtmp,<span class="string">'position'</span>,[0 0 1 1],<span class="string">'xlim'</span>,[0 fpos(3)],<span class="string">'ylim'</span>,[0 fpos(4)]);
0391     tmp = text(0,0,Opt.title, ttlprops{:}, <span class="string">'horiz'</span>, <span class="string">'left'</span>, <span class="string">'vert'</span>, <span class="string">'bottom'</span>);
0392     ttlex = get(tmp, <span class="string">'extent'</span>);
0393     ttlwidth = ceil(ttlex(3)) + 4; <span class="comment">% Add a little padding</span>
0394     ttlheight = ceil(ttlex(4));
0395     
0396     <span class="keyword">if</span> ttlwidth &gt; sum(colWidth)
0397         colWidth(end) = colWidth(end) + (ttlwidth-sum(colWidth));
0398     <span class="keyword">end</span>
0399     close(figtmp);
0400 <span class="keyword">end</span>
0401 
0402 <span class="comment">% Locate bottom left corner of each legend symbol, text box, and title</span>
0403 
0404 xsymbnew = [0 cumsum(colWidth(1:end-1))]+2;
0405 ysymbnew = (rowHeight*Opt.nrow + vmarginPx)-(1:Opt.nrow)*rowHeight;
0406 [xsymbnew, ysymbnew] = meshgrid(xsymbnew, ysymbnew);
0407 xsymbnew = xsymbnew(1:nobj);
0408 ysymbnew = ysymbnew(1:nobj);
0409 
0410 xtext = xsymbnew + 1 + symbolWidthPx;
0411 ytext = ysymbnew;<span class="comment">% + 1;</span>
0412 
0413 xsymbold = zeros(nobj,1);
0414 ysymbold = 1 - (1/nobj)*(1:nobj);
0415 
0416 wnewleg = sum(colWidth);
0417 hnewleg = rowHeight*Opt.nrow + vmarginPx;
0418 
0419 <span class="keyword">if</span> addtitle
0420     xttl = wnewleg/2;
0421     yttl = hnewleg;
0422     hnewleg = hnewleg + ttlheight;
0423 <span class="keyword">end</span>
0424     
0425 <span class="comment">% Get legend position in bufferunit and translate to pixels</span>
0426 
0427 legpos = <a href="#_sub1" class="code" title="subfunction legpos = positionleg(href, w, h, anchor, buffer, bufunit)">positionleg</a>(Opt.ref, wnewleg, hnewleg, Opt.anchor, Opt.buffer, Opt.bufunit);
0428 tmpax = axes(<span class="string">'units'</span>, Opt.bufferunit, <span class="string">'position'</span>, legpos,<span class="string">'visible'</span>,<span class="string">'off'</span>);
0429 legpos = <a href="getpos.html" class="code" title="function [pos,unit]=getpos(h,fmt,href,opt)">getpos</a>(tmpax, <span class="string">'px'</span>);
0430 delete(tmpax);
0431 
0432 <span class="comment">%-------------------</span>
0433 <span class="comment">% Create legend</span>
0434 <span class="comment">%-------------------</span>
0435 
0436 <span class="comment">% Create the legend axis</span>
0437 
0438 hnew.leg = axes(<span class="string">'units'</span>, <span class="string">'pixels'</span>, <span class="keyword">...</span>
0439                <span class="string">'position'</span>, legpos, <span class="keyword">...</span>
0440                <span class="string">'xlim'</span>, [0 legpos(3)], <span class="keyword">...</span>
0441                <span class="string">'ylim'</span>, [0 legpos(4)], <span class="keyword">...</span>
0442                <span class="string">'xtick'</span>, [], <span class="keyword">...</span>
0443                <span class="string">'ytick'</span>, [], <span class="keyword">...</span>
0444                <span class="string">'box'</span>, <span class="string">'on'</span>, <span class="keyword">...</span>
0445                <span class="string">'parent'</span>, figh);
0446 
0447 <span class="comment">% Copy the text strings to the new legend</span>
0448            
0449 textProps = {<span class="string">'FontAngle'</span>,<span class="string">'FontName'</span>,<span class="string">'FontSize'</span>,<span class="string">'FontUnits'</span>,<span class="string">'FontWeight'</span>,<span class="string">'Interpreter'</span>,<span class="string">'HorizontalAlignment'</span>,<span class="string">'VerticalAlignment'</span>};
0450 textVals = get(h.obj(1:nobj), textProps);
0451 
0452 hnew.obj = zeros(size(h.obj));
0453 <span class="keyword">for</span> it = 1:nobj
0454     props = [textProps; textVals(it,:)];
0455     hnew.obj(it) = text(xtext(it), ytext(it), h.textstr{it}, props{:}, <span class="keyword">...</span>
0456                         <span class="string">'horizontalalignment'</span>, <span class="string">'left'</span>, <span class="keyword">...</span>
0457                         <span class="string">'verticalalignment'</span>, <span class="string">'bottom'</span>);
0458 <span class="keyword">end</span>
0459 
0460 <span class="comment">% Copy the symbols to the new legend</span>
0461 
0462 nsymbol = length(h.obj) - nobj;
0463 
0464 <span class="keyword">for</span> ii = 1:nsymbol
0465     
0466     <span class="keyword">if</span> strcmp(get(h.obj(nobj+ii), <span class="string">'type'</span>), <span class="string">'hggroup'</span>)
0467         
0468         tag = get(h.obj(nobj+ii),<span class="string">'Tag'</span>);
0469         <span class="keyword">if</span> ~isempty(tag)
0470             [blah, idx] = ismember(tag,h.textstr);
0471         <span class="keyword">end</span>
0472         
0473         chld = findall(h.obj(nobj+ii), <span class="string">'type'</span>, <span class="string">'line'</span>, <span class="string">'-or'</span>, <span class="string">'type'</span>, <span class="string">'patch'</span>);       
0474         <span class="keyword">for</span> ic = 1:length(chld)
0475             xy = get(chld(ic), {<span class="string">'xdata'</span>, <span class="string">'ydata'</span>});
0476             
0477             xnorm = xy{1}./symbolWidthNm;
0478             ynorm = (xy{2}- (1-idx*rowHeightNm))./rowHeightNm;
0479 
0480             xnew = xnorm * symbolWidthPx + xsymbnew(idx);
0481             ynew = ynorm * rowHeight     + ysymbnew(idx);
0482             
0483             set(chld(ic), <span class="string">'xdata'</span>, xnew, <span class="string">'ydata'</span>, ynew);
0484         <span class="keyword">end</span>
0485         
0486         hnew.obj(nobj+ii) = copyobj(h.obj(nobj+ii), hnew.leg);
0487         
0488     <span class="keyword">else</span>   
0489         
0490         hnew.obj(nobj+ii) = copyobj(h.obj(nobj+ii), hnew.leg);
0491         
0492         tag = get(h.obj(nobj+ii),<span class="string">'Tag'</span>);
0493         <span class="keyword">if</span> ~isempty(tag)
0494             [blah, idx] = ismember(tag,h.textstr);
0495         <span class="keyword">end</span>
0496         xy = get(h.obj(nobj+ii), {<span class="string">'xdata'</span>, <span class="string">'ydata'</span>});
0497         
0498         xnorm = xy{1}./symbolWidthNm;
0499         ynorm = (xy{2}- (1-idx*rowHeightNm))./rowHeightNm;
0500         
0501         xnew = xnorm * symbolWidthPx + xsymbnew(idx);
0502         ynew = ynorm * rowHeight     + ysymbnew(idx);
0503         
0504         set(hnew.obj(nobj+ii), <span class="string">'xdata'</span>, xnew, <span class="string">'ydata'</span>, ynew);
0505     <span class="keyword">end</span>
0506     
0507 <span class="keyword">end</span>
0508 
0509 <span class="comment">% Add title</span>
0510 
0511 <span class="keyword">if</span> addtitle
0512     text(xttl, yttl, Opt.title, ttlprops{:}, <span class="string">'horiz'</span>, <span class="string">'center'</span>, <span class="string">'vert'</span>, <span class="string">'bottom'</span>);
0513 <span class="keyword">end</span>
0514 
0515 <span class="comment">% Add box or hide axis</span>
0516 
0517 <span class="keyword">if</span> Opt.box
0518     set(hnew.leg, <span class="string">'box'</span>, <span class="string">'on'</span>);
0519 <span class="keyword">else</span>
0520     set(hnew.leg, <span class="string">'visible'</span>, <span class="string">'off'</span>);
0521 <span class="keyword">end</span>
0522 
0523 <span class="comment">% Delete the temporary legend</span>
0524 
0525 delete(h.leg);
0526 
0527 <span class="comment">% Return focus to previously-current axis</span>
0528 
0529 set(figh, <span class="string">'currentaxes'</span>, currax);
0530 drawnow; <span class="comment">% Not sure why this is necessary for the currentaxes to take effect, but it is</span>
0531 
0532 <span class="comment">%-------------------</span>
0533 <span class="comment">% Resize callback</span>
0534 <span class="comment">%-------------------</span>
0535 
0536 rsz = get(figh, <span class="string">'ResizeFcn'</span>);
0537 
0538 Lf.ref        = Opt.ref;
0539 Lf.w          = wnewleg;
0540 Lf.h          = hnewleg;
0541 Lf.anchor     = Opt.anchor;
0542 Lf.buffer     = Opt.buffer;
0543 Lf.bufunit    = Opt.bufunit;
0544 Lf.bufferunit = Opt.bufferunit;
0545 Lf.plotobj    = h.labeledobj;
0546 Lf.legobj     = hnew.obj;
0547 
0548 
0549 <span class="keyword">if</span> isequal(rsz, @<a href="#_sub2" class="code" title="subfunction resizefig(hfig, ed, oldrsz)">resizefig</a>)
0550     Lf.oldrsz = [];
0551 <span class="keyword">else</span>
0552     Lf.oldrsz = rsz;
0553 <span class="keyword">end</span>
0554 
0555 <span class="keyword">if</span> isappdata(figh, <span class="string">'legflexchildren'</span>)
0556     ch = getappdata(figh, <span class="string">'legflexchildren'</span>);
0557     setappdata(figh, <span class="string">'legflexchildren'</span>, [ch hnew.leg]);
0558 <span class="keyword">else</span>
0559     setappdata(figh, <span class="string">'legflexchildren'</span>, hnew.leg);
0560 <span class="keyword">end</span>
0561 
0562 setappdata(hnew.leg, <span class="string">'legflex'</span>, Lf);
0563 set(figh, <span class="string">'ResizeFcn'</span>, @<a href="#_sub2" class="code" title="subfunction resizefig(hfig, ed, oldrsz)">resizefig</a>);
0564 
0565 <span class="comment">%-------------------</span>
0566 <span class="comment">% Output</span>
0567 <span class="comment">%-------------------</span>
0568 
0569 out = {hnew.leg, hnew.obj, h.labeledobj, h.textstr};
0570 varargout = out(1:nargout);
0571 
0572 
0573 <span class="comment">%***** Subfunctions *****</span>
0574 
0575 <span class="comment">%------------------------</span>
0576 <span class="comment">% Position new legend</span>
0577 <span class="comment">%------------------------</span>
0578 
0579 <a name="_sub1" href="#_subfunctions" class="code">function legpos = positionleg(href, w, h, anchor, buffer, bufunit)</a>
0580 <span class="comment">% ap: position vector for reference object</span>
0581 <span class="comment">% lp: position vector for legend</span>
0582 
0583 <span class="keyword">if</span> strcmp(get(href, <span class="string">'type'</span>), <span class="string">'figure'</span>)
0584     tmp = axes(<span class="string">'parent'</span>, href,<span class="string">'position'</span>, [0 0 1 1],<span class="string">'visible'</span>,<span class="string">'off'</span>);
0585     pos = <a href="getpos.html" class="code" title="function [pos,unit]=getpos(h,fmt,href,opt)">getpos</a>(tmp, bufunit);
0586     delete(tmp);
0587 <span class="keyword">else</span>
0588     pos = <a href="getpos.html" class="code" title="function [pos,unit]=getpos(h,fmt,href,opt)">getpos</a>(href, bufunit);
0589 <span class="keyword">end</span>
0590 
0591 htmp = axes(<span class="string">'units'</span>, <span class="string">'pixels'</span>, <span class="string">'position'</span>, [0 0 w h], <span class="string">'visible'</span>,<span class="string">'off'</span>);
0592 lpos = <a href="getpos.html" class="code" title="function [pos,unit]=getpos(h,fmt,href,opt)">getpos</a>(htmp, bufunit);
0593 delete(htmp);
0594 w = lpos(3);
0595 h = lpos(4);
0596 
0597 <span class="comment">% Find anchor locations on reference object</span>
0598 
0599 refxy = [<span class="keyword">...</span>
0600     pos(1)          pos(2)+pos(4)
0601     pos(1)+pos(3)/2 pos(2)+pos(4)
0602     pos(1)+pos(3)   pos(2)+pos(4)
0603     pos(1)+pos(3)   pos(2)+pos(4)/2
0604     pos(1)+pos(3)   pos(2)
0605     pos(1)+pos(3)/2 pos(2)
0606     pos(1)          pos(2)
0607     pos(1)          pos(2)+pos(4)/2];
0608 
0609 <span class="comment">% How bottom left relates to each anchor point</span>
0610 
0611 shift = [<span class="keyword">...</span>
0612     0       -h
0613     -w/2    -h
0614     -w      -h
0615     -w      -h/2
0616     -w      0
0617     -w/2    0
0618     0       0
0619     0       -h/2];
0620 
0621 <span class="comment">% Legend location</span>
0622 
0623 corner = refxy(anchor(1),:) + buffer + shift(anchor(2),:);
0624 legpos = [corner w h];
0625 
0626 
0627 <span class="comment">%------------------------</span>
0628 <span class="comment">% Resize function</span>
0629 <span class="comment">%------------------------</span>
0630 
0631 <a name="_sub2" href="#_subfunctions" class="code">function resizefig(hfig, ed, oldrsz)</a>
0632 
0633 <span class="comment">% Find legendflex axes</span>
0634 
0635 ax = getappdata(hfig, <span class="string">'legflexchildren'</span>);
0636 
0637 <span class="keyword">for</span> ia = 1:length(ax)
0638     
0639     <span class="keyword">if</span> ishandle(ax(ia)) <span class="comment">% if axis has been deleted, ignore this</span>
0640     
0641         Lf = getappdata(ax(ia), <span class="string">'legflex'</span>);
0642 
0643         <span class="comment">% ResizeFcn unassociated w/ legendflex (if applicable)</span>
0644 
0645         <span class="keyword">if</span> ~isempty(Lf.oldrsz)
0646             <span class="keyword">if</span> iscell(Lf.oldrsz)
0647                 feval(Lf.oldrsz{1}, hfig, ed, Lf.oldrsz{2:end});
0648             <span class="keyword">else</span>
0649                 feval(Lf.oldrsz, hfig, ed);
0650             <span class="keyword">end</span>
0651         <span class="keyword">end</span>
0652         
0653         <span class="comment">% Get current size of legend axis (in case user altered it)</span>
0654         
0655         axunit = get(ax(ia), <span class="string">'units'</span>);
0656         
0657         pos = <a href="getpos.html" class="code" title="function [pos,unit]=getpos(h,fmt,href,opt)">getpos</a>(ax(ia), <span class="string">'px'</span>);
0658         Lf.w = pos(3) ;
0659         Lf.h = pos(4);
0660 <span class="comment">%         fprintf('%.2f %.2f\n', Lf.w, Lf.h);</span>
0661 
0662         <span class="comment">% Redraw legend with updated position</span>
0663 
0664         legpos = <a href="#_sub1" class="code" title="subfunction legpos = positionleg(href, w, h, anchor, buffer, bufunit)">positionleg</a>(Lf.ref, Lf.w, Lf.h, Lf.anchor, Lf.buffer, Lf.bufunit);
0665         tmpax = axes(<span class="string">'units'</span>, Lf.bufferunit, <span class="string">'position'</span>, legpos,<span class="string">'visible'</span>,<span class="string">'off'</span>);
0666         legpos = <a href="getpos.html" class="code" title="function [pos,unit]=getpos(h,fmt,href,opt)">getpos</a>(tmpax, <span class="string">'px'</span>);
0667         delete(tmpax);
0668         
0669         set(ax(ia), <span class="string">'unit'</span>, <span class="string">'pixels'</span>);
0670         set(ax(ia), <span class="string">'position'</span>, legpos); 
0671         set(ax(ia), <span class="string">'unit'</span>, axunit);
0672             
0673         <span class="comment">% Check for changed properties of all lines and patches</span>
0674 
0675         str = cellstr(num2str(Lf.plotobj));
0676         [htmp.leg, htmp.obj, htmp.labeledobj, htmp.textstr] = legend(Lf.plotobj, str);
0677 
0678         objtype = get(Lf.legobj, <span class="string">'type'</span>);
0679         isline = strcmp(objtype, <span class="string">'line'</span>);
0680         ispatch = strcmp(objtype, <span class="string">'patch'</span>);
0681         ishg = strcmp(objtype, <span class="string">'hggroup'</span>);
0682         hgidx = find(ishg);
0683 
0684         lobj = [Lf.legobj(isline) htmp.obj(isline)];
0685         pobj = [Lf.legobj(ispatch) htmp.obj(ispatch)];
0686 
0687         <span class="keyword">if</span> ~isempty(hgidx)
0688             <span class="keyword">for</span> ih = hgidx
0689                 chldln1 = findall(Lf.legobj(ih), <span class="string">'type'</span>, <span class="string">'line'</span>);
0690                 chldln2 = findall(htmp.obj(ih), <span class="string">'type'</span>, <span class="string">'line'</span>); 
0691 
0692                 lobj = [lobj; [chldln1 chldln2]];
0693 
0694                 chldpa1 = findall(Lf.legobj(ih), <span class="string">'type'</span>, <span class="string">'patch'</span>);
0695                 chldpa2 = findall(htmp.obj(ih), <span class="string">'type'</span>, <span class="string">'patch'</span>); 
0696 
0697                 pobj = [pobj; [chldpa1 chldpa2]];
0698 
0699             <span class="keyword">end</span>
0700         <span class="keyword">end</span>
0701 
0702         lprops = {<span class="string">'color'</span>,<span class="string">'linestyle'</span>,<span class="string">'linewidth'</span>,<span class="string">'marker'</span>,<span class="string">'markersize'</span>,<span class="string">'markeredgecolor'</span>,<span class="string">'markerfacecolor'</span>};
0703         <span class="keyword">for</span> il = 1:size(lobj,1)
0704             lvals = get(lobj(il,2), lprops);
0705             pv = [lprops; lvals];
0706             set(lobj(il,1), pv{:});
0707         <span class="keyword">end</span>
0708 
0709         pprops = {<span class="string">'cdata'</span>,<span class="string">'cdatamapping'</span>,<span class="string">'edgealpha'</span>,<span class="string">'edgecolor'</span>,<span class="string">'facealpha'</span>,<span class="string">'facecolor'</span>,<span class="string">'linestyle'</span>,<span class="string">'linewidth'</span>,<span class="string">'marker'</span>,<span class="string">'markeredgecolor'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'markersize'</span>};
0710         <span class="keyword">for</span> ip = 1:size(pobj,1)
0711             pvals = get(pobj(ip,2), pprops);
0712             pv = [pprops; pvals];
0713             set(pobj(ip,1), pv{:});
0714         <span class="keyword">end</span>
0715 
0716         delete(htmp.leg);
0717     <span class="keyword">end</span>
0718         
0719 <span class="keyword">end</span>
0720 
0721 
0722 
0723     
0724</pre></div>
<hr><address>Generated on Mon 18-Nov-2019 14:53:30 by <strong>B.&nbsp;Gustavsson</strong> with <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2003</address>
</body>
</html>