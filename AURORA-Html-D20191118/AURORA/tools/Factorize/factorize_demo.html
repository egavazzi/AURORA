<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of factorize_demo</title>
  <meta name="keywords" content="factorize_demo">
  <meta name="description" content="% THE FACTORIZE OBJECT for solving linear systems">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html AURORA --><!-- ../menu.html tools --><!-- menu.html Factorize -->
<h1>factorize_demo
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>% THE FACTORIZE OBJECT for solving linear systems</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">% THE FACTORIZE OBJECT for solving linear systems

 Copyright 2009, Timothy A. Davis, University of Florida.  June 4, 2009.
 davis@cise.ufl.edu
 http://www.cise.ufl.edu/~davis

 This is a demonstration of the FACTORIZE object for solving linear
 systems and least-squares problems, and for computations with the
 matrix inverse and pseudo-inverse.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="factorize.html" class="code" title="function F = factorize (A,try_chol)">factorize</a>	FACTORIZE an object-oriented method for solving linear systems</li><li><a href="inverse.html" class="code" title="function S = inverse (X)">inverse</a>	INVERSE factorized representation of inv(A).</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">%% THE FACTORIZE OBJECT for solving linear systems</span>
0002 <span class="comment">%</span>
0003 <span class="comment">% Copyright 2009, Timothy A. Davis, University of Florida.  June 4, 2009.</span>
0004 <span class="comment">% davis@cise.ufl.edu</span>
0005 <span class="comment">% http://www.cise.ufl.edu/~davis</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% This is a demonstration of the FACTORIZE object for solving linear</span>
0008 <span class="comment">% systems and least-squares problems, and for computations with the</span>
0009 <span class="comment">% matrix inverse and pseudo-inverse.</span>
0010 
0011 <span class="comment">%% Rule Number One: never multiply by the inverse, inv(A)</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% Use backslash or a matrix factorization instead (LU, CHOL, or QR).</span>
0014 
0015 <span class="comment">%% Rule Number Two:  never break Rule Number One</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% However, the problem with Rule Number One is that it can be hard to</span>
0018 <span class="comment">% figure out which matrix factorization to use and how to use it.  Using</span>
0019 <span class="comment">% LU, CHOL, or QR is complicated, particularly if you want the best</span>
0020 <span class="comment">% performance.  BACKSLASH (MLDIVIDE) is great, but it can't be reused when</span>
0021 <span class="comment">% solving multiple systems (x=A\b and y=A\c).  Its syntax doesn't match</span>
0022 <span class="comment">% the use of the inverse in mathematical expressions, either.</span>
0023 <span class="comment">%</span>
0024 <span class="comment">% The goal of the FACTORIZE object is to solve this problem ...</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% &quot;Don't let that INV go past your eyes; to solve that system, FACTORIZE!&quot;</span>
0027 
0028 <span class="comment">%% How to use BACKSLASH solve A*x=b</span>
0029 <span class="comment">%</span>
0030 <span class="comment">% First, let's create a square matrix A and a right-hand-side b for a</span>
0031 <span class="comment">% linear system A*x=b.  There are many ways to solve this system.  The</span>
0032 <span class="comment">% best way is to use x=A\b.  The residual r is a vector of what's left</span>
0033 <span class="comment">% over in each equation, and its norm tells you how accurately the system</span>
0034 <span class="comment">% was solved.</span>
0035 
0036 format compact ;
0037 A = rand (3)
0038 b = rand (3,1)
0039 x = A\b
0040 r = b-A*x ;
0041 norm (r)
0042 
0043 <span class="comment">%% BACKSLASH versus INV ... let the battle begin</span>
0044 <span class="comment">%</span>
0045 <span class="comment">% The backslash operation x=A\b is mathematically the same as x=inv(A)*b.</span>
0046 <span class="comment">% However, backslash is faster and more accurate since it uses a matrix</span>
0047 <span class="comment">% factorization instead of multiplying by the inverse.  Even though your</span>
0048 <span class="comment">% linear algebra textbook might write x=A^(-1)*b as the solution to the</span>
0049 <span class="comment">% system A*x=b, your textbook author never means for you to compute the</span>
0050 <span class="comment">% inverse.</span>
0051 <span class="comment">%</span>
0052 <span class="comment">% These next statements give the same answer, so what's the big deal?</span>
0053 
0054 S = inv(A) ;
0055 x = S*b
0056 x = A\b
0057 
0058 <span class="comment">%%</span>
0059 <span class="comment">% The big deal is that you should care about speed and you should care even</span>
0060 <span class="comment">% more about accuracy.  BACKSLASH relies on matrix factorization (LU, CHOL,</span>
0061 <span class="comment">% QR, or other specialized methods).  It's faster and more reliable than</span>
0062 <span class="comment">% multiplying by the inverse, particularly for large matrices and sparse</span>
0063 <span class="comment">% matrices.  Here's an illustration of how pathetic inv(A)*b can be.</span>
0064 
0065 A = gallery (<span class="string">'frank'</span>,16) ; xtrue = ones (16,1) ; b = A*xtrue ;
0066 
0067 x = inv(A)*b ; norm (b-A*x)
0068 x = A\b      ; norm (b-A*x)
0069 
0070 <span class="comment">%%</span>
0071 <span class="comment">% The performance difference between BACKSLASH and INV for even small</span>
0072 <span class="comment">% sparse matrices is striking.</span>
0073 
0074 load west0479 ;
0075 A = west0479 ;
0076 n = size (A,1)
0077 b = rand (n,1) ;
0078 tic ; x = A\b ; toc
0079 norm (b-A*x)
0080 tic ; x = inv(A)*b ; toc
0081 norm (b-A*x)
0082 
0083 <span class="comment">%%</span>
0084 <span class="comment">% What if you want to solve multiple systems?  Use a matrix factorization.</span>
0085 <span class="comment">% But which one?  And how do you use it?  Here are some alternatives using</span>
0086 <span class="comment">% LU for the sparse west0479 matrix, but some are faster than others.</span>
0087 
0088 tic ; [L,U]     = lu(A) ; x1 = U \ (L \ b)         ; t1=toc ; nz1=nnz(L+U);
0089 tic ; [L,U,P]   = lu(A) ; x2 = U \ (L \ P*b)       ; t2=toc ; nz2=nnz(L+U);
0090 tic ; [L,U,P,Q] = lu(A) ; x3 = Q * (U \ (L \ P*b)) ; t3=toc ; nz3=nnz(L+U);
0091 
0092 fprintf (<span class="string">'1: nnz(L+U): %5d time: %8.4f resid: %e\n'</span>, nz1,t1, norm(b-A*x1));
0093 fprintf (<span class="string">'2: nnz(L+U): %5d time: %8.4f resid: %e\n'</span>, nz2,t2, norm(b-A*x2));
0094 fprintf (<span class="string">'3: nnz(L+U): %5d time: %8.4f resid: %e\n'</span>, nz3,t3, norm(b-A*x3));
0095 
0096 <span class="comment">%% LU and LINSOLVE are fast and accurate but complicated to use</span>
0097 <span class="comment">%</span>
0098 <span class="comment">% A quick look at ``help lu'' will scroll off your screen.  For full</span>
0099 <span class="comment">% matrices, [L,U,p] = lu (A,'vector') is fastest.  Then for the</span>
0100 <span class="comment">% forward/backsolves, use LINSOLVE instead of BACKSLASH for even faster</span>
0101 <span class="comment">% performance.  But for sparse matrices, use the optional 'Q' output of LU</span>
0102 <span class="comment">% so you get a good fill-reducing ordering.  But you can't use 'Q' if the</span>
0103 <span class="comment">% matrix is full.  But LINSOLVE doesn't work on sparse matrices.</span>
0104 <span class="comment">%</span>
0105 <span class="comment">% But ... Ack!  That's getting complicated ...</span>
0106 <span class="comment">%</span>
0107 <span class="comment">% Here's the best way to solve A*x=b and A*y=c when A is full and</span>
0108 <span class="comment">% unsymmetric:</span>
0109 
0110 n = 1000 ;
0111 A = rand (n) ;
0112 b = rand (n,1) ;
0113 c = rand (n,1) ;
0114 tic ; [L,U,p] = lu (A, <span class="string">'vector'</span>) ; LUtime = toc
0115 
0116 tic ; x = U \ (L \ b (p,:)) ;
0117       y = U \ (L \ c (p,:)) ; toc
0118 
0119 tic ; opL = struct (<span class="string">'LT'</span>, true) ;
0120       opU = struct (<span class="string">'UT'</span>, true) ;
0121       x = linsolve (U, linsolve (L, b(p,:), opL), opU) ;
0122       y = linsolve (U, linsolve (L, c(p,:), opL), opU) ; toc
0123 
0124 <span class="comment">%% INV is easy to use, but slow and inaccurate</span>
0125 <span class="comment">%</span>
0126 <span class="comment">% Oh bother!  Using LU and LINSOLVE is too complicated.  You just want to</span>
0127 <span class="comment">% solve your system.  Let's just compute inv(A) and use it twice.  Easy to</span>
0128 <span class="comment">% write, but slower and less accurate ...</span>
0129 
0130 S = inv (A) ;
0131 x = S*b ; norm (b-A*x)
0132 y = S*c ; norm (c-A*y)
0133 
0134 <span class="comment">%%</span>
0135 <span class="comment">% Sometimes using the inverse seems inevitable.  For example, your textbook</span>
0136 <span class="comment">% might show the Schur complement formula as S = A-B*inv(D)*C.  This can be</span>
0137 <span class="comment">% done without inv(D) in one of two ways: SLASH or BACKSLASH (MRDIVIDE or</span>
0138 <span class="comment">% MLDIVIDE to be precise).</span>
0139 <span class="comment">%</span>
0140 <span class="comment">% inv(A)*B and A\B are mathematically equivalent, as are B*inv(A) and B/A,</span>
0141 <span class="comment">% so these three methods give the same results (ignoring computational</span>
0142 <span class="comment">% errors, which are worse for inv(D)).  Only the first equation looks like</span>
0143 <span class="comment">% the equation in your textbook, however.</span>
0144 
0145 A = rand (200) ; B = rand (200) ; C = rand (200) ; D = rand (200) ;
0146 
0147 tic ; S1 = A - B*inv(D)*C ; toc ;
0148 tic ; S2 = A - B*(D\C) ;    toc ;
0149 tic ; S3 = A - (B/D)*C ;    toc ;
0150 
0151 <span class="comment">%% So the winner is ... nobody</span>
0152 <span class="comment">%</span>
0153 <span class="comment">% BACKSLASH: mostly simple to use (except remember that Schur complement</span>
0154 <span class="comment">%       formula?).  Fast and accurate ... but slow if you want to solve</span>
0155 <span class="comment">%       two linear systems with the same matrix A.</span>
0156 <span class="comment">%</span>
0157 <span class="comment">% LU, QR, CHOL: fast and accurate.  Awful syntax to use.  Drag out your</span>
0158 <span class="comment">%       linear algebra textbook if you want to use these in MATLAB.</span>
0159 <span class="comment">%       Whenever I use them I have to derive them from scratch, even</span>
0160 <span class="comment">%       though I *wrote* most of the sparse factorizations used in MATLAB!</span>
0161 <span class="comment">%</span>
0162 <span class="comment">% INV: slow and inaccurate.  Wins big on ease-of-use, though, since it's a</span>
0163 <span class="comment">%       direct plug-in for all your nice mathematical formulas.</span>
0164 <span class="comment">%</span>
0165 <span class="comment">% No method is best on all three criterion: speed, accuracy, and ease of</span>
0166 <span class="comment">% use.</span>
0167 <span class="comment">%</span>
0168 <span class="comment">% Is there a solution?  Yes ... keeping reading ...</span>
0169 
0170 <span class="comment">%% The FACTORIZE object to the rescue</span>
0171 <span class="comment">%</span>
0172 <span class="comment">% The FACTORIZE method is just as easy to use as INV, but just as fast and</span>
0173 <span class="comment">% accurate as BACKSLASH, LU, QR, CHOL, and LINSOLVE.</span>
0174 <span class="comment">%</span>
0175 <span class="comment">% F = factorize(A) computes the factorization of A and returns it as an</span>
0176 <span class="comment">% object that you can reuse to solve a linear system with x=F\b.  It picks</span>
0177 <span class="comment">% LU, QR, or Cholesky for you, just like BACKSLASH.</span>
0178 <span class="comment">%</span>
0179 <span class="comment">% S = inverse(A) is simpler yet.  It does NOT compute inv(A), but</span>
0180 <span class="comment">% factorizes A.  When multiplying S*b, it doesn't mulitply by the inverse,</span>
0181 <span class="comment">% but uses the correct forward/backsolve equations to solve the linear</span>
0182 <span class="comment">% system.</span>
0183 
0184 n = 1000 ;
0185 A = rand (n) ;
0186 b = rand (n,1) ;
0187 c = rand (n,1) ;
0188 
0189 tic ;                       x = A\b ; y = A\c ; toc
0190 tic ; S = inv(A) ;          x = S*b ; y = S*c ; toc
0191 tic ; F = <a href="factorize.html" class="code" title="function F = factorize (A,try_chol)">factorize</a>(A) ;    x = F\b ; y = F\c ; toc
0192 tic ; S = <a href="inverse.html" class="code" title="function S = inverse (X)">inverse</a>(A) ;      x = S*b ; y = S*c ; toc
0193 
0194 <span class="comment">%% Least-squares problems</span>
0195 <span class="comment">%</span>
0196 <span class="comment">% Here are some different methods for solving a least-squares problem when</span>
0197 <span class="comment">% your system is over-determined.  The last two methods are the same.</span>
0198 
0199 A = rand (1000,200) ;
0200 b = rand (1000,1) ;
0201 
0202 tic ; x = A\b            ; toc, norm (A'*A*x-A'*b)
0203 tic ; x = pinv(A)*b      ; toc, norm (A'*A*x-A'*b)
0204 tic ; x = <a href="inverse.html" class="code" title="function S = inverse (X)">inverse</a>(A)*b   ; toc, norm (A'*A*x-A'*b)
0205 tic ; x = <a href="factorize.html" class="code" title="function F = factorize (A,try_chol)">factorize</a>(A)\b ; toc, norm (A'*A*x-A'*b)
0206 
0207 <span class="comment">%%</span>
0208 <span class="comment">% FACTORIZE is better than BACKSLASH because you can reuse the</span>
0209 <span class="comment">% factorization for different right-hand-sides.  For full-rank matrices,</span>
0210 <span class="comment">% it's better than PINV because it's faster (and PINV fails for sparse</span>
0211 <span class="comment">% matrices).</span>
0212 
0213 A = rand (1000,200) ;
0214 b = rand (1000,1) ;
0215 c = rand (1000,1) ;
0216 
0217 tic ;                  ; x = A\b ; y = A\c ; toc
0218 tic ; S = pinv(A)      ; x = S*b ; y = S*c ; toc
0219 tic ; S = <a href="inverse.html" class="code" title="function S = inverse (X)">inverse</a>(A)   ; x = S*b ; y = S*c ; toc
0220 tic ; F = <a href="factorize.html" class="code" title="function F = factorize (A,try_chol)">factorize</a>(A) ; x = F\b ; y = F\c ; toc
0221 
0222 <span class="comment">%% Underdetermined systems</span>
0223 <span class="comment">%</span>
0224 <span class="comment">% The under-determined system A*x=b where A has more columns than rows has</span>
0225 <span class="comment">% many solutions.  x=A\b finds a basic solution (some of the entries in x</span>
0226 <span class="comment">% are zero).  pinv(A)*b finds a minimum 2-norm solution, but it's slow.  QR</span>
0227 <span class="comment">% factorization will do the same if A has full rank.  That's what the</span>
0228 <span class="comment">% factorize(A) and inverse(A) methods do.</span>
0229 
0230 A = rand (200,1000) ;
0231 b = rand (200,1) ;
0232 
0233 tic ; x = A\b            ; toc, norm (x)
0234 tic ; x = pinv(A)*b      ; toc, norm (x)
0235 tic ; x = <a href="inverse.html" class="code" title="function S = inverse (X)">inverse</a>(A)*b   ; toc, norm (x)
0236 tic ; x = <a href="factorize.html" class="code" title="function F = factorize (A,try_chol)">factorize</a>(A)\b ; toc, norm (x)
0237 
0238 <span class="comment">%% Computing selected entries in the inverse or pseudo-inverse</span>
0239 <span class="comment">%</span>
0240 <span class="comment">% If you want just a few entries from the inverse, it's still better to</span>
0241 <span class="comment">% formulate the problem as a system of linear equations and use a matrix</span>
0242 <span class="comment">% factorization instead of computing inv(A).  The FACTORIZE object does this</span>
0243 <span class="comment">% for you, by overloading the subsref operator.</span>
0244 
0245 A = rand (1000) ;
0246 
0247 tic ; S = inv (A)     ; S (2:3,4), toc
0248 tic ; S = <a href="inverse.html" class="code" title="function S = inverse (X)">inverse</a> (A) ; S (2:3,4), toc
0249 
0250 <span class="comment">%% Computing the entire inverse or pseudo-inverse</span>
0251 <span class="comment">%</span>
0252 <span class="comment">% Rarely, and I mean RARELY, you really do need the inverse.  More</span>
0253 <span class="comment">% frequently what you want is the pseudo-inverse.  You can force a</span>
0254 <span class="comment">% factorization to become a plain matrix by converting it to double.  Note</span>
0255 <span class="comment">% that inverse(A) only handles full-rank matrices (either dense or</span>
0256 <span class="comment">% sparse), whereas pinv(A) works for all dense matrices (not sparse).</span>
0257 <span class="comment">%</span>
0258 <span class="comment">% The explicit need for inv(A) (or S=A\eye(n), which is the same thing) is</span>
0259 <span class="comment">% RARE.  If you ever find yourself multiplying by the inverse, then you</span>
0260 <span class="comment">% know one thing for sure.  You know with certainty that you don't know</span>
0261 <span class="comment">% what you're doing.</span>
0262 
0263 A = rand (500) ;
0264 tic ; S1 = inv (A) ;            ; toc
0265 tic ; S2 = double (<a href="inverse.html" class="code" title="function S = inverse (X)">inverse</a> (A)) ; toc
0266 norm (S1-S2)
0267 
0268 A = rand (500,400) ;
0269 tic ; S1 = pinv (A)             ; toc
0270 tic ; S2 = double (<a href="inverse.html" class="code" title="function S = inverse (X)">inverse</a> (A)) ; toc
0271 norm (S1-S2)
0272 
0273 <span class="comment">%% Update/downdate of a dense Cholesky factorization</span>
0274 <span class="comment">%</span>
0275 <span class="comment">% Wilkinson considered the update/downdate of a matrix factorization to be</span>
0276 <span class="comment">% a key problem in computational linear algebra.  The idea is that you</span>
0277 <span class="comment">% first factorize a matrix.  Next, make a low-rank change to A, and patch</span>
0278 <span class="comment">% up (or down...) the factorization so that it becomes the factorization of</span>
0279 <span class="comment">% the new matrix.  In MATLAB, this only works for dense symmetric positive</span>
0280 <span class="comment">% definite matrices, via cholupdate.  This is much faster than computing</span>
0281 <span class="comment">% the new factorization from scratch.</span>
0282 
0283 n = 1000 ;
0284 A = rand (n) ;
0285 A = A*A' + n*eye (n) ;
0286 w = rand (n,1) ; t = rand (n,1) ; b = rand (n,1) ;
0287 F = <a href="factorize.html" class="code" title="function F = factorize (A,try_chol)">factorize</a> (A) ;
0288 
0289 tic ; F = F + w ; x = F\b ; toc
0290 tic ; y = (A+w*w')\b ;      toc
0291 norm (x-y)
0292 
0293 tic ; F = F - t ; x = F\b ; toc
0294 tic ; y = (A+w*w'-t*t')\b ; toc
0295 norm (x-y)
0296 
0297 <span class="comment">%% Caveat Executor</span>
0298 <span class="comment">%</span>
0299 <span class="comment">% One caveat:  If you have a large number of very small systems to solve,</span>
0300 <span class="comment">% the object-oriented overhead of creating and using an object can dominate</span>
0301 <span class="comment">% the run time, at least in MATLAB R2009a.  For this case, if you want the</span>
0302 <span class="comment">% best performance, stick with BACKSLASH, or LU and LINSOLVE (just extract</span>
0303 <span class="comment">% the appropriate formulas from the M-files in the FACTORIZE package).</span>
0304 <span class="comment">%</span>
0305 <span class="comment">% Hopefully the object-oriented overhead will drop in future versions of</span>
0306 <span class="comment">% MATLAB, and you can ignore this caveat.</span>
0307 
0308 A = rand (10) ; b = rand (10,1) ; F = <a href="factorize.html" class="code" title="function F = factorize (A,try_chol)">factorize</a> (A) ;
0309 
0310 tic ; <span class="keyword">for</span> k = 1:10000, x = F\b ; <span class="keyword">end</span> ; toc
0311 
0312 tic ; <span class="keyword">for</span> k = 1:10000, x = A\b ; <span class="keyword">end</span> ; toc
0313 
0314 [L,U,p] = lu (A, <span class="string">'vector'</span>) ;
0315 opL = struct (<span class="string">'LT'</span>, true) ;
0316 opU = struct (<span class="string">'UT'</span>, true) ;
0317 tic ; 
0318 <span class="keyword">for</span> k = 1:10000
0319     x = linsolve (U, linsolve (L, b(p,:), opL), opU) ;
0320 <span class="keyword">end</span>
0321 toc
0322 
0323 <span class="comment">%% Summary</span>
0324 <span class="comment">%</span>
0325 <span class="comment">% So ... don't use INV, and don't worry about how to use LU, CHOL, or QR</span>
0326 <span class="comment">% factorization.  Just install the FACTORIZE package, and you're on your</span>
0327 <span class="comment">% way.  Assuming you are now in the Factorize/ directory, cut-and-paste</span>
0328 <span class="comment">% these commands into your command window:</span>
0329 <span class="comment">%</span>
0330 <span class="comment">%   addpath (pwd)</span>
0331 <span class="comment">%   savepath</span>
0332 <span class="comment">%</span>
0333 <span class="comment">% And remember ...</span>
0334 <span class="comment">%</span>
0335 <span class="comment">% &quot;Don't let that INV go past your eyes; to solve that system, FACTORIZE!&quot;</span>
0336</pre></div>
<hr><address>Generated on Mon 18-Nov-2019 14:53:30 by <strong>B.&nbsp;Gustavsson</strong> with <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2003</address>
</body>
</html>